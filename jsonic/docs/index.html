<?xml version="1.0" encoding="UTF-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>jsonic - simple json encoder/decoder for java</title>
<style type="text/css">
	body { margin: 0px; font: 10pt sans-serif; }
	.title { font: bold 20pt sans-serif; color: #6699FF; margin: 10px 5px 5px 5px; }
	.title a { color: #6699FF; text-decoration: none; }
	h1 .subtitle { font: italic 12pt sans-serif; color: gray; }
	.bar { color: white; background: gray; padding: 1px 5px; }
	.menu { position: absolute; top: 70px; left: 0px; padding: 8px; width: 140px; background: white; }
	.menu ul { margin: 0px; padding: 0px 0px 0px 16px; }
	.main { margin-left: 160px; padding: 5px 16px; width: 600px; line-height: 1.5; border-left: 1px solid silver; }
	h2 { font: bold 12pt sans-serif; color: #666666; margin: 30px 0px 10px 0px;
		border-left: 10px solid #6699FF; border-bottom: 1px solid #6699FF; padding: 0px 5px; }
	h3 { font: bold 11pt sans-serif; border-bottom: 1px solid gray; margin: 30px 0px 12px 0px; }
	h3 .subtitle { font: 9pt sans-serif; }
	h4 { font: bold 10pt sans-serif;  margin: 20px 0px 10px 0px; }
	h4 .subtitle { font: 9pt sans-serif; }
	a { color: darkblue; }
	p { margin: 0px 0px 1em 0px; padding: 0px; }
	.source { border: 1px solid silver; font: 9pt monospace; padding: 16px; background-color: #E0FFFF; }
	.comment { color: #0066FF; font-family: monospace; }
	.em { font-weight: bold; color: #000099; font-family: monospace; }
	.elem { font-weight: bold; color: #000099; }
	table { border: 1px solid black; font: 9pt sans-serif; width: 100%; border-collapse: collapse; 
		margin: 0px 0px 1em 0px; }
	th { background-color: silver; border: 1px solid gray; }
	td { border: 1px solid gray; padding: 2px 2px;}
	sup { font-size: 8pt; }
	.caption { font: 8pt sans-serif; margin: 10px; }
	.copyright { color: white; background: gray; padding: 0px 16px; }
</style>
</head>
<body>
<a href="http://sourceforge.jp/" style="position:absolute; top: 7px; left: 664px;"><img src="http://sourceforge.jp/sflogo.php?group_id=2893" width="96" height="31" border="0" alt="SourceForge.jp"></a>
<h1 class="title"><a href="">JSONIC</a> <span class="subtitle">- simple json encoder/decoder for java</span></h1>
<div class="bar">[MENU] >>></div>
<div class="menu">
<ul>
	<li><a href="#introduction">JSONICとは</a></li>
	<li><a href="#download">ダウンロード</a></li>
	<li><a href="#usage">使い方</a>
		<ul>
			<li><a href="#usage_basic">基本的な使い方</a></li>
			<li><a href="#usage_advanced">高度な使い方</a></li>
			<li><a href="#webservice">JSON Web Service Servlet</a></li>
		</ul>
	</li>
	<li><a href="api/index.html">Javadoc</a></li>
	<li><a href="#license">ライセンス</a></li>
	<li><a href="#releasenote">リリースノート</a></li>
</ul>
</div>
<div class="main">
<h2 id="introduction">JSONICとは</h2>
<p>JSONICは、Java用のシンプルかつ高機能なJSONエンコーダー/デコーダーライブラリです。<br />
Java用のJSONライブラリは他にも複数ありますが、JSONICは<a href="http://www.rfc-editor.org/rfc/rfc4627.txt">RFC 4627</a>に従った正式なJSON形式でのデコード/エンコードを行いながらも、プログラミング言語に依存する情報をJSON内に含めることなくPOJO(Plain Old Java Object)と自然な変換を行える点に特徴があります。</p>
<p>使い方も非常に簡単です。</p>
<pre class="source">
import net.arnx.jsonic.JSON;

<span class="comment">// POJOをJSONに変換します</span>
String text = <span class="em">JSON.encode(</span>new Hoge()<span class="em">)</span>;

<span class="comment">// JSONをPOJOに変換します</span>
Hoge hoge = <span class="em">JSON.decode(</span>text, Hoge.class<span class="em">)</span>;
</pre>

<h2 id="download">ダウンロード</h2>
<p>JSONICの現時点での最新バージョンは0.9.7です。</p>
<p><a href="http://sourceforge.jp/projects/jsonic/files/">ダウンロードはこちらから</a>できます。なお、JSONICのビルド/実行には、Javaバージョン5.0以上が必要です。</p>

<h2 id="usage">使い方</h2>

<h3 id="usage_basic">基本的な使い方</h3>

<p>通常の用途では、二つの静的メソッドencode/decodeだけ利用すれば事足ります。</p>
<h4>■ encodeメソッド <span class="subtitle">- POJOからJSONへの変換</span></h4>
<p>POJOからJSONに変換する場合は、encodeを使います。デフォルトでは、空白などを含まない可読性の低いJSONが出力されますが、二番目の引数をtrueにすることで可読性の高いJSONが出力されるようになります（Pretty Printモード）。</p>
<pre class="source">
<span class="comment">// 変換対象のPOJOを準備</span>
Hoge hoge = new Hoge();
hoge.number = 10;      <span class="comment">// public field</span>
hoge.setString("aaa"); <span class="comment">// publid property</span>
hoge.setArray(new int[] {1, 2, 3});

<span class="comment">// POJOをJSONに変換します。戻り値は {"number":10,"string":"aaa","array":[1,2,3]}となります</span>
String text = <span class="em">JSON.encode(</span>hoge<span class="em">)</span>;

<span class="comment">// POJOを可読性の高いJSONに変換します。戻り値は次のような文字列になります
// {
//     "number": 10,
//     "string": "aaa",
//     "array": [1, 2, 3]
// }</span>
String text = <span class="em">JSON.encode(</span>hoge, true<span class="em">)</span>; 
</pre>
<p>POJOからJSONへの変換ルールは次の通りです。</p>
<table summary="POJOからJSONへの変換ルール">
<tr><th style="width: 50%">変換元（Java）</th><th style="width: 50%">変換先（JSON）</th></tr>
<tr><td>Map</td><td rowspan="2">object</td></tr>
<tr><td>Object<sup>(※1)</sup></td></tr>
<tr><td>boolean[], short[], int[], long[], float[], double[], Object[]</td><td rowspan="2">array</td></tr>
<tr><td>Collection</td></tr>
<tr><td>char[], CharSequence</td><td rowspan="3">string</td></tr>
<tr><td>char, Character</td></tr>
<tr><td>TimeZone, Pattern, Type, Member</td></tr>
<tr><td>byte[]</td><td>string (BASE64)</td></tr>
<tr><td>Locale</td><td>string (言語コード-国コード)</td></tr>
<tr><td>byte, short, int, long, float, double</td><td rowspan="2">number<sup>(※2)</sup></td></tr>
<tr><td>Number</td></tr>
<tr><td>Date, Calendar</td><td>number (1970年からのミリ秒)</td></tr>
<tr><td>boolean, Boolean</td><td>true/false</td></tr>
<tr><td>null</td><td>null</td></tr>
</table>
<div class="caption">
(※1) 対象となるインスタンスをパブリック・getterメソッド、パブリック・フィールドの優先順で探索します。staticが付加されたメソッドやフィールド、transientが付加されたフィールドは対象となりません。<br />
(※2) NaN, Infinity, -Infinityに限りそれぞれ文字列"NaN", "Infinity", "-Infinity"に変換されます。
</div>
<p>また、org.w3c.dom.Document/ElementからJSONへの変換もサポートしています。詳しくは「<a href="#xmltojson">高度な使い方 - XMLからJSONへの変換</a>」の項をご覧ください。</p>
<p>なお、JSONはobjectかarrayで始まる必要があるため、直接、intやStringのインスタンスをencodeメソッドの引数に指定した場合エラーとなります。</p>

<h4>■ decodeメソッド <span class="subtitle">- JSONからPOJOへの変換</span></h4>
<p>JSONからPOJOに変換する場合は、decodeを使います。デフォルトでは、object, array, string, number, true/false, nullをHashMap, ArrayList, String, BigDecimal, Boolean, nullに変換しますが、二番目の引数に変換先のクラスを指定することでそのクラスのインスタンスにデータをセットして返してくれます。また、この処理はパブリック・フィールドやパブリック・プロパティ、配列やコレクションのデータを再帰的に辿り実行されますので、一般的なJavaBeansであればencodeして作られたJSONからの逆変換も可能です（Generics型にも対応しています）。</p>
<p>なお、JSON文字列が不正な場合にはJSONParseExceptionを投げ、型の変換に失敗した場合はJSONConvertExceptionを投げます（変換に失敗した際の動作を変更したい場合には、handleConversionFailureをオーバーライドします）。</p>
<pre class="source">
<span class="comment">// JSONをPOJOに変換します。戻り値としてサイズが4のArrayListが返されます</span>
List list = (List)<span class="em">JSON.decode(</span>"[1, \"a\", {}, false]"<span class="em">)</span>;

<span class="comment">// JSONをHogeクラスのインスタンスに変換します（キャストは不要です）</span>
Hoge hoge = <span class="em">JSON.decode(</span>"{\"number\": 10, \"array\": [1, 2, 3]}", Hoge.class<span class="em">)</span>;
</pre>
<p>JSONからPOJOへの変換ルールは次の通りです。</p>
<table summary="JSONからPOJOへの変換ルール">
<tr><th style="width: 20%">変換元（JSON）</th><th style="width: 40%">指定された型</th><th style="width: 40%">変換先（Java）</th></tr>
<tr><td rowspan="4">object</td><td>なし, Object, Map</td><td>LinkedHashMap</td></tr>
<tr><td>SortedMap</td><td>TreeMap</td></tr>
<tr><td>その他のMap派生型</td><td>指定された型</td></tr>
<tr><td>その他の型</td><td>指定された型（パブリック・フィールド／プロパティに値をセット)<sup>(※3)</sup></td></tr>
<tr><td rowspan="9">array</td><td>なし, Object, Collection, List</td><td>ArrayList</td></tr>
<tr><td>Set</td><td>LinkedHashSet</td></tr>
<tr><td>SortedSet</td><td>TreeSet</td></tr>
<tr><td>その他のCollection派生型</td><td>指定された型</td></tr>
<tr><td>short[], byte[], int[], long[], float[], double[]<br />Object[]派生型</td><td>指定された型</td></tr>
<tr><td>Locale</td><td>Locale（「言語コード」「国コード」「バリアントコード」からなる配列とみなし変換）</td></tr>
<tr><td>Map</td><td>インデックスの値をキーとするLinkedHashMap</td></tr>
<tr><td>SortedMap</td><td>インデックスの値をキーとするTreeMap</td></tr>
<tr><td>その他のMap派生型</td><td>インデックスの値をキーとする指定された型のMap</td></tr>
<tr><td rowspan="14">string</td><td>なし, Object, CharSequence, String</td><td>String</td></tr>
<tr><td>char</td><td>char（幅0の時は'\u0000', 2文字以上の時は1文字目）</td></tr>
<tr><td>Character</td><td>Character（幅0の時はnull, 2文字以上の時は1文字目）</td></tr>
<tr><td>Appendable</td><td>StringBuilder</td></tr>
<tr><td>その他のAppendable派生型</td><td>指定された型（値をappend）</td></tr>
<tr><td>Enum派生型</td><td>指定された型（値をEnum.valueOfで変換）</td></tr>
<tr><td>Date派生型,<br />Calendar派生型</td><td>指定された型（文字列をDateFormatで変換）</td></tr>
<tr><td>byte, short, int, long, float, double,<br />Byte, Short, Integer, Long, Float, Double,<br />BigInteger, BigDecimal</td><td>指定された型（文字列を数値とみなし変換）</td></tr>
<tr><td>byte[]</td><td>byte[]（文字列をBASE64とみなし変換）</td></tr>
<tr><td>Locale</td><td>Locale（文字列を「言語コード」「国コード」「バリアントコード」が何らかの句読文字で区切られているとみなし変換）</td></tr>
<tr><td>Pattern</td><td>Pattern（文字列をパターンとみなし変換）</td></tr>
<tr><td>Class</td><td>Class（文字列をClass.forNameを使い変換）</td></tr>
<tr><td>TimeZone</td><td>TimeZone（文字列をTimeZone.getTimeZoneを使い変換）</td></tr>
<tr><td>boolean, Boolean</td><td>指定された型（"", "false", "no", "off", "NaN"の時false、その他の時true）</td></tr>
<tr><td rowspan="5">number</td><td>なし, Object, Number, BigDecimal</td><td>BigDecimal</td></tr>
<tr><td>byte, short, int, long, float, double,<br />Byte, Short, Integer, Long, Float, Double,<br />BigInteger</td><td>指定された型</td></tr>
<tr><td>Date派生型,<br />Calendar派生型</td><td>指定された型（数値を1970年からのミリ秒とみなし変換）</td></tr>
<tr><td>boolean, Boolean</td><td>指定された型（0以外の時true、0の時false）</td></tr>
<tr><td>Enum派生型</td><td>指定された型（int値をEnum.ordinal()に従い変換）</td></tr>
<tr><td rowspan="5">true/false</td><td>なし, Object, Boolean</td><td>Boolean</td></tr>
<tr><td>char, Character</td><td>指定された型（trueの時'1'、falseの時'0'）</td></tr>
<tr><td>float, double, Float, Double</td><td>指定された型（trueの時1.0、falseの時NaN）</td></tr>
<tr><td>byte, short, int, long,<br />Byte, Short, Integer, Long,<br />BigInteger</td><td>指定された型（trueの時1、falseの時0）</td></tr>
<tr><td>boolean</td><td>boolean</td></tr>
<tr><td rowspan="4">null</td><td>なし, Object</td><td>null</td></tr>
<tr><td>byte, short, int, long, float, double</td><td>0</td></tr>
<tr><td>boolean</td><td>false</td></tr>
<tr><td>char</td><td>'\u0000'</td></tr>
</table>
<div class="caption">
(※3) 対象となるインスタンスに対しパブリックなsetterメソッド、パブリックなフィールドの優先順で探索します。
staticやtransientのメソッド/フィールドは対象となりません。
なお、プロパティ名は、単純比較が失敗した場合、LowerCamel記法に変換したものと比較し、次に末尾に「_」を付けて比較します（これは、予約語に対応するためです）。
</div>

<h3 id="usage_advanced">高度な使い方</h3>
<p>JSONICでは、フレームワークなどでの利用を想定していくつかの便利な機能を用意しています。</p>
<ul>
<li><a href="#extends">継承による機能拡張</a></li>
<li><a href="#io">Reader/InputStreamによるparse</a></li>
<li><a href="#generics">総称型を指定してのdecode/parse</a></li>
<li><a href="#liberalparsing">柔軟な読み込み</a></li>
<li><a href="#innerclass">内部クラスを利用したデコード</a></li>
<li><a href="#maxdepth">最大深度の設定</a></li>
<li><a href="#xmltojson">XMLからJSONへの変換</a></li>
</ul>


<h4 id="extends">■ 継承による機能拡張</h4>
<p>JSONICは、フレームワークでの利用を考慮しインスタンスを生成したり、継承して拡張することができるように設計してあります。
なお、インスタンスを生成して利用する場合は、encode/decodeメソッドの代わりにformat/parseメソッドを利用します。</p>
<pre class="source">
<span class="comment">// インスタンスを生成します</span>
<span class="em">JSON</span> json = new <span class="em">JSON()</span>;

<span class="comment">// POJOをJSONに変換します(encodeと同じ機能)</span>
String text = json<span class="em">.format(</span>new Hoge()<span class="em">)</span>;

<span class="comment">// POJOを可読性の高いJSONに変換します(Pretty Printモード)</span>
json.<span class="em">setPrettyPrint(</span>true<span class="em">)</span>;
String text = json<span class="em">.format(</span>new Hoge()<span class="em">)</span>;

<span class="comment">// JSONをPOJOに変換します(decodeと同じ機能)</span>
Map map = (Map)json<span class="em">.parse(</span>text<span class="em">)</span>;

<span class="comment">// JSONをHogeクラスのインスタンスに変換します(decodeと同じ機能)</span>
Hoge hoge = json<span class="em">.parse(</span>text, Hoge.class<span class="em">)</span>;
</pre>

<p>DIコンテナなどを使いインスタンスを生成したり、独自の変換を追加するために次のようなオーバーライド可能なメソッドが用意されています。</p>
<pre class="source">
JSON json = new JSON() {
  
  <span class="comment">// 引数で指定された内容に従い変換します。例外が投げられた場合、
  // JSONConvertExceptionでラップされ呼び出し元に通知されます。</span>
  protected <span class="em">&lt;T&gt; T convert(Object key, Object value,
    Class&lt;? extends T&gt; c, Type type)</span> throws Exception {
    
    <span class="comment">// JSON arrrayをjava.awt.Pointに変換する例です。
    // さらに下の階層を変換する場合はconvertChildメソッドを呼び出してください。</span>
    if (c == Point.class && value instanceof List) {
      return (T)new Point(
      	convertChild(0, ((List)value).get(0), int.class, int.class), 
      	convertChild(1, ((List)value).get(1), int.class, int.class)
      );
    }
    return super.convert(key, value, c, type);
  }
  
  <span class="comment">// 型cに対するインスタンスを生成します</span>
  protected <span class="em">Object create(Class c)</span> {
    return super.create(c);
  }
      
  <span class="comment">// Class cにおいて、Member mを無視します（parse/formatの両方で有効です）</span>
  protected <span class="em">boolean ignore(Class c, Member m)</span> {
    <span class="comment">// デフォルトでは、static/transparentのメンバおよびObjectクラスで宣言された
    // メンバの場合、trueを返します。</span>
    return super.ignore(c, m);
  }    
};
</pre>
<p>※version 0.9.5までは、変換方法の拡張はconvertメソッドで行っていましたが、0.9.6以降はhandleConversionFailureで行う必要があります。</p>

<h4 id="io">■ Reader/InputStreamによるparse</h4>
<p>staticメソッドのJSON.decodeでは文字列からPOJOへの変換しか対応できませんが、parseメソッドの場合にはjava.io.Readerやjava.io.InputStreamからJSONデータを読み込むことができます。</p>
<pre class="source">
<span class="comment">// ReaderからのJSONの読み込み</span>
Hoge hoge = (new JSON()).<span class="em">parse(</span>new FileReader("sample.json"), Hoge.class<span class="em">)</span>;

<span class="comment">// InputStreamからのJSONの読み込み（ファイルはUnicodeである必要があります<sup>(※4)</sup>）</span>
Hoge hoge = (new JSON()).<span class="em">parse(</span>new FileInputStream("sample.json"), Hoge.class<span class="em">)</span>;
</pre>
<div class="caption">
(※4) UTF-8/UTF-16BE/UTF-16LE/UTF-32BE/UTF-32LEから自動判別します。<br />
</div>

<h4 id="generics">■ 総称型を指定してのdecode/parse</h4>
<p>Java 5.0で追加された総称型は動的な情報としては利用できないため、decode/parseメソッドのClass型引数として直接指定することができません。その代わり、FieldやMethodを利用することで間接的に指定することができます。</p>
<pre class="source">
public class JSONConfigLoader {
  private Map&lt;String, Hoge&gt; config;
  
  public Map load(Reader reader) throws JSONParseException, IOException {
    JSON json = new JSON();
    
    <span class="comment">// これはコンパイルエラー</span>
    config = json.<span class="em">parse(</span>reader, Map&lt;String, Hoge&gt;.class<span class="em">)</span>;
    
    <span class="comment">// これならOK</span>
    config = json.<span class="em">parse(</span>reader,
        Map.class,
        getClass().getField("config").getGenericType()<span class="em">)</span>;
        
    return config;
  }
}
</pre>

<h4 id="liberalparsing">■ 柔軟な読み込み <span class="subtitle">- 妥当でないJSONのデコード</span></h4>
<p>JSONICはポステルの法則（送信するものに関しては厳密に、受信するものに関しては寛容に）に従い、妥当でないJSONであっても読み込みが可能なように作成されています。<a 
href="http://www.rfc-editor.org/rfc/rfc4627.txt">RFC 4627</a>に規定された内容との相違点は以下の通りです。</p>
<ul>
  <li>Cスタイルの複数行コメント（/**/）、C++スタイルの行コメント（//）およびシェルスクリプトスタイルの行コメント（#）をコメントとして認識します。</li>
  <li>ルート要素がobjectの場合、一番外側の'{'と'}'を省略することができます（入力文字列が空白文字列やコメントのみの場合も空のobjectとみなされます）。</li>
  <li>シングルクォートで囲まれた文字列やJavaリテラルを文字列として認識します（ただし、シングルクォートで囲まれた場合はjavascriptと異なりエスケープを処理しません）。</li>
  <li>objectやarrayにおいて各要素が改行で区切られているとき','を省略することができます。</li>
  <li>objectにおいてキーに対する値がobjectの場合、':'を省略することができます。</li>
  <li>string中で改行やタブなどの制御文字を有効な文字として認識します。</li>
  <li>objectやarrayにおいて値が省略された場合、nullとして認識します。</li>
</ul>
<p>例えば、次のテキストは<a href="http://www.rfc-editor.org/rfc/rfc4627.txt">RFC 4627</a>では無効ですが、JSONICでは読み込むことが可能です。</p>
<pre class="source">
# database settings
database {
  description: 'ms sql server
	connecter settings'
  user: sa
  password: xxxx // you need to replace your password.
}

/* 
  equals to {"database": {
     "description": "ms sql server\n\tconnecter settings",
     "user": "sa", "password": "xxxx"}}
*/
</pre>
<p>※version 0.9.3まであった拡張モードは0.9.4以降廃止されました。</p>

<h4 id="innerclass">■ コンテキストの指定 <span class="subtitle">- 内部クラスを利用したデコード</span></h4>
<p>decode/parseメソッドの引数にClassオブジェクトを指定するということは、指定されたクラス通常publicでなければならないことを意味します。
しかし、JSONの設定ファイルを解析したいような場合は、内部クラスやパッケージ・デフォルトのクラスを利用したいことがあります。<br />
JSONICでは、decodeメソッドやparseメソッドの引数に指定されたクラスと同一のパッケージのクラスを自動的にアクセス可能に変更します。</p>
<pre class="source">
public class EnclosingClass {
  public void decode() {
    JSON json = <span class="em">new JSON(this)</span>; <span class="comment">// このクラスのコンテキストで動作</span>
    json.<span class="em">setContext(this)</span>; // <span class="comment">setContextを使って指定することも可能です</span>
    InnerClass ic = json.parse("{\"a\": 100}", InnerClass.class);
    
    System.out.println("ic.a = " + ic.a); <span class="comment">// ic.a = 100</span>
  }
  
  class InnerClass {
    public int a = 0;
  }
}
</pre>

<h4 id="maxdepth">■ setMaxDepth <span class="subtitle">- 最大深度の設定</span></h4>
<p>JSONICは、encode/format時に自分自身を戻すようなフィールドやプロパティ、配列を無視することで再帰による無限ループが発生することを防ぎます。
しかし、そのインスタンスにとって孫に当たるクラスが自分のインスタンスを返す場合にも再帰が発生してしまいます。JSONICでは、このような場合へ対処するため
単純に入れ子の深さに制限を設けています。なお、最大深度の設定はdecode/parse時にも有効ですので深すぎるデータの取得も避けることが可能となります。</p>
<p>この最大深度は、デフォルトでは32に設定されていますが変更することも可能です。</p>
<pre class="source">
<span class="comment">// 5階層以下の情報は取得しない</span>
json<span class="em">.setMaxDepth(</span>5<span class="em">)</span>;
</pre>

<h4 id="xmltojson">■ XMLからJSONへの変換</h4>
<p>JSONICでは、org.w3c.dom.Document/ElementからJSONへの変換もサポートしています。
方法は、通常と同じようにencode/formatの引数にorg.w3c.dom.Document/Elementのインスタンスを設定するだけです。</p>
<pre class="source">
Document doc = builder.parse(new File("sample.xml"));
String xmljson = JSON.<span class="em">encode(</span>doc<span class="em">)</span>;
</pre>
<p>例えば、下記のXMLの場合</p>
<pre class="source">
<span class="elem">&lt;feed xmlns="</span>http://www.w3.org/2005/Atom<span class="elem">"&gt;</span>
  <span class="elem">&lt;title&gt;</span>Feed Title<span class="elem">&lt;/title&gt;</span>
  <span class="elem">&lt;entry&gt;</span>
    <span class="elem">&lt;title&gt;</span>Entry Title<span class="elem">&lt;/title&gt;</span>
  <span class="elem">&lt;/entry&gt;</span>
<span class="elem">&lt;/feed&gt;</span>
</pre>
<p>次のようなJSONが生成されます（実際にはタグ間の空白文字もTextNodeとして出力されます）。</p>
<pre class="source">
{ "tagName": "feed", "attributes": {
    "xmlns": "http://www.w3.org/2005/Atom"
  },
  "childNodes": [
    { "tagName": "title", "childNodes": [ "Feed Title" ] },
    { "tagName": "entry", "childNodes": [
        { "tagName": "title", "childNodes": [ "Entry Title" ] }
    ]}
  ]
}
</pre>

<h3 id="webservice">JSON Web Service Servlet</h3>
<p>JSONICには、JSON-RPC1.0によるRPCモードとRestfull APIによるRESTモードの2 Way Web Service機能が用意されています。</p>
<p>※JSONRPCServletは0.9.6以降net.arnx.jsonic.web.WebServiceServletに置き換えられました。</p>

<h4>■ 設定方法</h4>
<p>JSON Web Service Servletの設定は簡単です。web.xmlにWebServiceServletを指定し、パスとClassのマッピングなどの設定を行うだけです。</p>
<pre class="source">
<span class="elem">&lt;servlet&gt;</span>
  <span class="elem">&lt;servlet-name&gt;</span>json-ws<span class="elem">&lt;/servlet-name&gt;</span>
  <span class="elem">&lt;servlet-class&gt;</span>net.arnx.jsonic.web.WebServiceServlet<span class="elem">&lt;/servlet-class&gt;</span>
  <span class="elem">&lt;init-param&gt;</span>
    <span class="elem">&lt;param-name&gt;</span>config<span class="elem">&lt;/param-name&gt;</span>
    <span class="elem">&lt;param-value&gt;</span>
    {
      "debug": true,
      "encoding": "UTF-8",
      "mappings": {
        "/[package]/[class].[ext]": "sample.web.${package}.service.${class}Service",
        "/[class].[ext]": "sample.${class}Service"
      }
    }
    <span class="elem">&lt;/param-value&gt;</span>
  <span class="elem">&lt;/init-param&gt;</span>
<span class="elem">&lt;/servlet&gt;</span>

<span class="elem">&lt;servlet-mapping&gt;</span>
  <span class="elem">&lt;servlet-name&gt;</span>json-ws<span class="elem">&lt;/servlet-name&gt;</span>
  <span class="elem">&lt;url-pattern&gt;</span>*.json<span class="elem">&lt;/url-pattern&gt;</span>
<span class="elem">&lt;/servlet-mapping&gt;</span>
</pre>
<p>configで設定できる値は次の通りです。</p>
<table summary="Config設定">
<tr><th>キー</th><th>値型</th><th>説明</th></tr>
<tr><td>container</td><td>net.arnx.jsonic.web.Container</td><td>クラスのインスタンスを取得するためのコンテナを設定します。デフォルトは、net.arnx.jsonic.web.Containerです。</td></tr>
<tr><td>debug</td><td>Boolean</td><td>デバッグモードの有効/無効を切り替えます。デフォルトはfalseです。</td></tr>
<tr><td>encoding</td><td>java.lang.String</td><td>Request/Responseの文字エンコーディングを設定します。デフォルトはUTF-8です。</td></tr>
<tr><td>mappings</td><td>java.util.Map&lt;String, String&gt;</td><td>URLパスとクラスのマッピングを行います。
パス中の[<i>name</i>]で囲まれた部分はクラス名の${<i>name</i>}に置換されます<sup>(※5)</sup>。
なお、RESTモードの場合、利用されなかった変数はメッセージボディとして送られてきたJSON objectの値として設定されメソッドに引き渡されます（RPCモードの場合は設定されません）。</td></tr>
<tr><td>definitions</td><td>java.util.Map&lt;String, Pattern&gt;</td><td>mappings中の変数の定義を正規表現で設定します。設定されない場合は[^/]+が設定されたものと扱われます。</td></tr>
</table>
<div class="caption">
(※5) 変数名のうち、classとpackageだけは特殊な扱いがされます。class変数中の文字列はUpperCamelに変換され、package変数中の「/」は「.」に変換されます。
また、URLパスにはコンテキストパスを含める必要はありません。
</div>

<h4>■ RPCモード</h4>
<p><a href="http://json-rpc.org/">JSON-RPC</a>は、JSONを使ったシンプルなRemote Procedure Callプロトコルです。JSON Web Service Servletでは、class変数の値が"rpc"であった場合、RPCモードとなります。</p>

<p>RPCモードでは、対象のパスに対し次のようなJSONをPOSTすることで、対象クラスのメソッドを呼び出すことができます（GET/PUT/DELETEは無効です）。paramsに指定された配列の値はメソッドの引数に指定された型に従い自動的に変換されます。なお、クラス名はUpperCamel、メソッド名はLowerCamelに自動的に変換されます。そして、実行後、戻り値がJSONに変換されクライアントに返されます。</p>
<pre class="source">
{
  "method": "[class].[method]",
  "params": [ arg1, arg2, ... ],
  "id": request_id
}
</pre>
<p>例えば、mappingsに "/[package]/[class].[ext]": "boo.${package}.${class}Service" という指定があった場合、 /foo/woo/rpc.jsonというパスに次のJSONがPOSTすると、boo.foo.woo.CalcServiceクラスのint plus(int a, int b)のようなメソッドが呼び出されます。</p>
<pre class="source">
{
  "method": "calc.plus",
  "params": [1,2],
  "id": 1
}
</pre>
<p>この時、レスポンスボディとしては次のような結果が返されます。</p>
<pre class="source">
{
  "result": 3,
  "error": null,
  "id": 1
}
</pre>

<p>RPCモードでエラーが発生した場合にはHTTP Status Codeとレスポンスボディの両方でクライアントに通知されます。</p>
<table summary="RPC エラー一覧">
<tr><th>エラー内容</th><th>HTTP Status Code</th><th>JSON error</th></tr>
<tr>
<td>JSONリクエストがJSON-RPCのリクエストとして不正</td>
<td>400&nbsp;Bad&nbsp;request</td>
<td><pre style="margin:0;">{
  "code": -32600,
  "message": "Invalid Request."
}</pre></td>
</tr>
<tr>
<td>methodで指定したクラス/メソッドが見つからない<sup>(※6)</sup></td>
<td>404&nbsp;Not&nbsp;found</td>
<td><pre style="margin:0;">{
  "code": -32601,
  "message": "Method not found."
}</pre></td>
</tr>
<tr>
<td>paramsが不適切<sup>(※7)</sup></td>
<td>400&nbsp;Bad&nbsp;request</td>
<td><pre style="margin:0;">{
  "code": -32602,
  "message": "Invalid params."
}</pre></td>
</tr>
<tr>
<td>JSONの解析に失敗した</td>
<td>400&nbsp;Bad&nbsp;request</td>
<td><pre style="margin:0;">{
  "code": -32700,
  "message": "Parse error."
}</pre></td>
</tr>
<tr>
<td>その他のエラー</td>
<td>500&nbsp;Internal&nbsp;Server&nbsp;Error</td>
<td><pre style="margin:0;">{
  "code": -32603,
  "message": "Internal error."
             or Exception.getMessage()
}</pre></td>
</tr>
</table>
<div class="caption">(※6) クラス/メソッドが見つからなかった時だけでなく、メソッドからUnsupportedOperationExceptionが投げられた場合も同じエラーが返されます。</div>
<div class="caption">(※7) Convertに失敗した場合だけでなく、メソッドからIllegalArgumentExceptionが投げられた場合も同じエラーが返されます。</div>

<h4>■ RESTモード</h4>
<p>class変数の値が"rpc"以外の場合はRESTモードになります。RESTモードでは、GET/POST/PUT/DELETEの四つのHTTP Methodに従い対象となったクラスの次の名前のメソッドが呼び出されます<sup>(※6)</sup>。そして、実行後、戻り値がJSONに変換されクライアントに返されます<sup>(※7)</sup>。</p>
<table summary="REST Method マッピング">
<tr><th>HTTP Method</th><th>Java メソッド名</th><th>引数</th></tr>
<tr><td>GET</td><td>find</td><td>URLのQueryを「.」で区切られた階層構造とみなし引数の型に従い変換し設定</td></tr>
<tr><td>POST</td><td>create</td><td>メッセージボディのJSONを引数の型に従い変換し設定</td></tr>
<tr><td>PUT</td><td>update</td><td>メッセージボディのJSONを引数の型に従い変換し設定</td></tr>
<tr><td>DELETE</td><td>delete</td><td>メッセージボディのJSONを引数の型に従い変換し設定</td></tr>
</table>
<p>なお、メッセージボディがJSON objectの場合、その値はリクエストパラメータ、パス変数の順で上書きされます。JSON arrayの場合は上書きされずに最後尾に追加されます。</p>
<div class="caption">
(※6) ブラウザなどでは、PUT/DELETEが使えない場合があります。そのような場合の代替手段として、リクエストパラメータに「_method=メソッド名」を指定することもできます。<br />
(※7) JSONはobjectかarrayより始まる必要があるため、それ以外の要素に変換される型の戻り値（例えば、boolean/int/Dateなど）の場合にはSC_NO_CONTENTが返されます。
</div>

<p>RESTモードでエラーが発生した場合にはHTTP Status Codeにてクライアントに通知されます。</p>
<table summary="RPC エラー一覧">
<tr><th>エラー内容</th><th>HTTP Status Code</th></tr>
<tr>
<td>クラス/メソッドが見つからない<sup>(※8)</sup></td>
<td>404&nbsp;Not&nbsp;found</td>
</tr>
<tr>
<td>送信されたJSONの解析/変換に失敗した<sup>(※9)</sup></td>
<td>400&nbsp;Bad&nbsp;request</td>
</tr>
<tr>
<td>その他のエラー</td>
<td>500&nbsp;Internal&nbsp;Server&nbsp;Error</td>
</tr>
</table>
<div class="caption">(※8) クラス/メソッドが見つからなかった時だけでなく、メソッドからUnsupportedOperationExceptionが投げられた場合も同じエラーが返されます。</div>
<div class="caption">(※9) Convertに失敗した場合だけでなく、メソッドからIllegalArgumentExceptionが投げられた場合も同じエラーが返されます。</div>


<h4>■ JSONP</h4>
<p>RESTモードでかつHTTP MethodがGETの場合、リクエストパラメータとしてcallback=Function名を指定することでJSONPによる返答を返すことができるようになります。</p>
<pre class="source">
&lt;script type="text/javascript" &gt;
  function call(value) {
    alert(value);
  }
&lt;/script&gt;

...

&lt;script type="text/javascript" src="http://host/hoge.json?callback=call"&gt;&lt;/script&gt;
</pre>

<h4>■ DI Container対応</h4>
<p>JSONRPCServletは、内部のコンテナを切り替えることで呼び出し対象のインスタンスを任意のDI Containerにて管理することが可能です。</p>

<pre class="source">
<span class="elem">&lt;servlet&gt;</span>
  <span class="elem">&lt;servlet-name&gt;</span>JSON-WebService<span class="elem">&lt;/servlet-name&gt;</span>
  <span class="elem">&lt;servlet-class&gt;</span>net.arnx.jsonic.web.WebServiceServlet<span class="elem">&lt;/servlet-class&gt;</span>
  <span class="elem">&lt;init-param&gt;</span>
    <span class="elem">&lt;param-name&gt;</span>config<span class="elem">&lt;/param-name&gt;</span>
    <span class="elem">&lt;param-value&gt;</span>
      <span class="comment">// "container": (net.arnx.jsonic.web.Containerを実装したクラス)</span>
      <span class="comment">// Seasar2対応Container</span>
      "container": "net.arnx.jsonic.web.S2Container"
      ...
    <span class="elem">&lt;/param-value&gt;</span>
  <span class="elem">&lt;/init-param&gt;</span>
<span class="elem">&lt;/servlet&gt;</span>
</pre>

<p>JSONICでは、<a href="http://www.seasar.org/">Seasar2</a>に対応したContainerを標準添付しています。このContainerを利用すると、Seasar2上で管理されているコンポーネントをWebServiceとして利用することができるようになります。</p>

<h2 id="license">ライセンス</h2>
<p>JSONICは、<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>下で配布します。</p>
<p>なお、書くまでもないことですが自分のライブラリへの組み込みやその際にパッケージ名や処理の変更など行っていただいて一向に構いません。保障はありませんが、ライセンスの範囲内でご自由にお使いください。</p>

<h2 id="report">バグ・要望の報告先</h2>
<p>バグや要望などは<a href="http://sourceforge.jp/projects/jsonic">JSONICプロジェクトサイト</a>のトラッキング情報あるいはフォーラムまでご連絡ください。</p>

<h2 id="releasenote">リリースノート</h2>

<h3>2008/03/02 version 0.9.7</h3>
<p>下記の機能追加・変更とバグ修正が行われています。</p>
<ul>
<li>JSONConvertExceptionがJSONParseExceptionを継承するようにしました。</li>
<li>MapのFormat時にkeyがStringでない場合ClassCastExceptionが発生し変換に失敗する問題を修正しました。</li>
<li>Parse時にJSON arrayからMapへの変換に対応しました。</li>
<li>Parse時にMapのキー値に対する変換が行われず常にStringに変換されていた問題を修正しました。</li>
<li>Parse時にJSON arrayやJSON objectから文字列への変換を行わないように変更しました。</li>
<li>Parse時にもsetMaxDepthで指定された階層以下のデータを無視するようになりました。</li>
<li>変換機能の拡張をconvertメソッドでも可能なように戻しました。</li>
<li>handleConvertFailuerによる継続処理のカスタマイズはニーズが低そうなので廃止しました。</li>
<li>JSON string, JSON numberから列挙型（Enum）への変換に対応しました。</li>
<li>仕様変更の影響を緩和するためnet.arnx.jsonic.web.Containerをinterfaceからclassに変更し、S2ContainerがContainerを継承するようにしました。</li>
</ul>

<h3>2008/02/18 version 0.9.6</h3>
<p>下記の機能追加・変更とバグ修正が行われています。</p>
<ul>
<li>Formatにてorg.w3c.dom.Document/ElementオブジェクトからJSONへの変換に対応しました。</li>
<li>Parse/Format時にJavaBeansのプロパティの扱いを制御できるよう、ignoreメソッドを追加しました。</li>
<li>今まで変換機能を拡張する場合にはconvertを継承するようにしていましたが、handleConversionFailureの継承により行うよう変更しました。</li>
<li>変換に失敗した際には、デフォルトでJSONConvertExceptionを投げるよう変更しました。この動作は、handleConversionFailureをoverrideすることで変更できます。</li>
<li>JSONParseExceptionをRuntimeExceptionを継承するように変更しました。</li>
<li>JSONRPCServletを機能強化しnet.arnx.jsonic.web.WebServiceServletとして再リリースしました（Seasar2のサポートも追加されています）。</li>
</ul>

<h3>2008/01/28 version 0.9.5</h3>
<p>下記の機能追加・変更とバグ修正が行われています。</p>
<ul>
<li>maxDepthのデフォルト値を32階層に変更しました。</li>
<li>InputStreamによるParseを実装しました。文字コードは、UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, UTF-32LEから自動判別されます。</li>
<li>Parse時にBOMが見つかった場合、無視するようにしました。</li>
<li>Parse時の日付変換ロジックを見直し、一般的にコンピュータが取り扱う日付フォーマットに対応しました。</li>
<li>Parse時にjava.sql.Date/java.sql.Time/java.sql.Timestamp/java.util.TimeZoneへの変換に対応しました。</li>
<li>Parse時に値が指定されない場合、nullが指定されたものとして取り扱うよう変更しました（ただし、カンマの省略はできません）。</li>
<li>Parse時に「'」で囲まれた文字列はエスケープ処理しないよう変更しました。</li>
<li>ParseのJSON objectからJavaBeanへの変換時、名称が常にJavaBean規約に合うように変換していましたが、マッチに失敗した場合のみ変換するように変更しました。</li>
<li>ParseのJSON objectからJavaBeanへの変換時、Javaの予約語にも対応できるよう末尾に「_」の付いたプロパティでもマッチできるよう変更しました。</li>
<li>convertメソッドの引数にkey値を追加しました。</li>
<li>余り役に立たないためinvokeメソッドは廃止しました。</li>
<li>各種JavaScriptライブラリのJSON対応が整ってきたため、JavaScript版のJSON.encode/JSON.decodeを削除しました。</li>
</ul>

<h3>2008/01/25 version 0.9.4.1</h3>
<p>パッケージミスと記載ミスの修正のみおこなわれています。</p>
<ul>
<li>net/arnx/jsonic/JSON.propertiesおよびnet/arnx/jsonic/JSON_ja.propertiesが配布用のjarファイルに含まれていない問題を修正しました。</li>
<li>net.arnx.jsonic.JSONクラスのコメントがParseExceptionを出力すると書かれていましたが、正しくはJSONParseExceptionですので記載を修正しました。</li>
</ul>

<h3>2007/09/09 version 0.9.4</h3>
<p>下記の機能追加とバグ修正が行われています。</p>
<ul>
<li>パーサは1クラスのみにするという自己規制を取り払いました。</li>
<li>拡張モードを廃止しparse時は常に柔軟な読み込みを可能とし、逆にformat時は厳格なJSONを出力するように変更しました。</li>
<li>JSON objectのname項目が空白、ハイフン、アンダースコアで区切られている場合や先頭の文字が大文字になっている場合でも、Java Classのプロパティ名に変換できるように変更しました。</li>
<li>JavaScript版のJSON.encode/JSON.decode機能を追加し、JSONRPCServlet経由で呼び出せるようにしました。</li>
<li>JSONParseExceptionを独立したクラスとするとともに、decode/parseメソッドをJSONParseExceptionをthrowするようにメソッド定義を変更しました。</li>
<li>Parseエラーを拾ったところで意味がないことに気づいたので、handleParseErrorを廃止しました。</li>
<li>formatの引数にWriterを指定した場合flushがされずOutOfMemoryErrorが発生していたのを修正しました。</li>
<li>メッセージをプロパティファイル化したことにより、英語と日本語にてエラーメッセージが出力できるようになりました。</li>
<li>順序を保存させるため、Map/Setのデフォルト変換先をHashMap/HashSetからLinkedHashMap/LinkedHashSetに変更しました。</li>
</ul>

<h3>2007/06/10 version 0.9.3</h3>
<p>主に機能追加、メソッドの整理が変更点です。</p>
<ul>
<li>Readerを使ったparseに対応しました。</li>
<li>java.lang.reflect.Type/Memberをのencodeに対応しました。</li>
<li>java.lang.Classのencode/decodeに対応しました。</li>
<li>java.util.regex.Patternのencode/decodeに対応しました。</li>
<li>真の内部クラス対応を行いました。setContextでEnclosingしているインスタンスを指定できます。</li>
<li>JSONRPCServletの文字化け対応を行いました。</li>
<li>JSONRPCServletでGETによるメソッド起動を可能にしました。なお、GETの場合にはJSONP機能が使えます。</li>
<li>setMaxDepthによる階層の制限を越えた場合、エラーにするのではなくnullを設定するように変更しました。</li>
<li>parseで利用するStringBuilderを再利用するように変更しました。</li>
<li>handleParseExceptionの仕様を見直しました。</li>
</ul>

<h3>2007/06/03 version 0.9.2</h3>
<p>下記のバグ修正と機能追加を行いました。</p>
<ul>
<li>継承の比較順序が逆になっており、convert時に変換元が変換先のClassを継承している場合にnullに変換されていたバグを修正</li>
<li>JSON-RPCの簡易実装を追加しました（JSONRPCServlet）</li>
</ul>

<h3>2007/06/02 version 0.9.1</h3>
<p>下記のバグ修正と機能追加を行いました。</p>
<ul>
<li>charとCharacterでboolean値の変換規則に一貫性を持たせるように変更</li>
<li><del>inner</del>public以外のclassであっても、引数に指定されたクラスと同一のパッケージ内であれば、encode/decodeするように対応</li>
</ul>

<h3>2007/05/27 version 0.9.0</h3>
<p>今まで日記上でほそぼそと公開していたSimple JSON Class for Javaを仕様などを整理し名前も新たに0.9にリバージョンして公開（機能面での変更はありませんが、微妙に変換ルールや仕様を調整してあります）。</p>
</div>

<div class="copyright">Copyright (C) 2007-2008 Hidekatsu Izuno All right reserved.</div>
</body>
</html>