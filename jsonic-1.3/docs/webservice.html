<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>WebサービスAPI (JSONIC 1.3)</title>
<style type="text/css">
	html { overflow-x: hidden; height:100%; }
	body { width: 100%; height: 100%; margin: 0px; padding: 0px; font: 10pt sans-serif; z-index: 1; }
	.sidebar { width: 160px; height: 100%;  margin: 0px; padding: 0px; background: white;
		position: fixed; top: 0px; left: 0px; bottom: 0px; overflow: hidden; z-index: 2; }
	.title { width: 160px; height: 46px; margin: 0px; padding: 0px; }
	.title a { position: absolute; top: 8px; left: 5px; overflow: hidden; }
	.menu { width: 160px; margin: 0px; padding: 0px; }
	.head { width: 100%; margin: 0px 160px 0px 0px; padding: 0px; }
	.head .subtitle { position: absolute; top: 18px; left: 160px; }
	.sf { height: 46px; margin: 0px; padding: 0px; }
	.sf a { position: absolute; top: 8px; right: 20px; }
	.main { margin: 0px 0px 0px 160px; padding: 0px; }
	.bar { margin: 0px; padding: 0px 10px; }
	
	.main { line-height: 1.5; border-left: 1px solid silver; padding: 15px 20px 15px 20px; }
	.title { font: bold 20pt sans-serif; color: #6699FF; }
	.title a { color: #6699FF; text-decoration: none; }
	.subtitle { font: italic 12pt sans-serif; color: gray; }
	.bar { color: white; background: gray; font: bold 8pt sans-serif; text-align: right; }
	.menu { margin: 15px 0px 15px 15px; padding: 0px; list-style-type: none; }
	.menu ul { margin: 0px; padding: 0px 0px 0px 20px; font-size: 8pt; list-style-image: url(images/marker.jpg); }
	.menu li { line-height: 1.5; }
	.menu li a { text-decoration: none; }
	.main ul { list-style-image: url(images/marker.jpg); }
	h2 { font: bold 12pt sans-serif; margin: 30px 0px 10px 0px; border-width: 2px ; border-style: solid; 
		border-color: silver gray gray silver; padding: 3px;
		background-image: url(images/header.jpg); background-position: center center; line-height: 1.0; }
	h3 { font: bold 11pt sans-serif; border-bottom: 1px solid gray; margin: 30px 0px 12px 0px;
		padding: 1px; line-height: 1.0; }
	h3 .subtitle { font: 9pt sans-serif; padding: 1px; line-height: 1.0; }
	a { color: darkblue; }
	p { margin: 0px 0px 1em 0px; padding: 0px; }
	.warning { border: 1px solid red; background-color: #FFFF66; padding: 5px; margin-bottom: 5px; }
	.source { border: 1px solid silver; font: 9pt monospace; padding: 16px; background-color: #E0FFFF; }
	.console { border: 1px solid black; font: 9pt monospace; color: white; padding: 16px; background-color: navy; }
	.comment { color: #0066FF; font-family: monospace; }
	.em { font-weight: bold; color: #000099; font-family: monospace; }
	.elem { font-weight: bold; color: #000099; }
	.table { border: 1px solid black; font: 9pt sans-serif; width: 100%; border-collapse: collapse; 
		margin: 0px 0px 1em 0px; }
	.table th { background-color: silver; border: 1px solid gray; white-space: nowrap; }
	.table td { border: 1px solid gray; padding: 2px 2px;}
	sup { font-size: 8pt; }
	.caption { font: 8pt sans-serif; margin: 10px; }
	.copyright { text-align: right; }
</style>
<!--[if IE 6]>
<style type="text/css">
	.sidebar { position: absolute; }
</style>
<![endif]--> 
</head>
<body>
<div class="sidebar">
<h1 class="title"><a href="index.html"><img src="images/jsonic_logo.jpg" width="136" height="34" alt="jsonic" style="vertical-align: -10px; border-width:0px;" /></a></h1>
<div class="bar">Version 1.3</div>
<ul class="menu">
	<li><a href="index.html">JSONICとは</a></li>
	<li><a href="index.html#download">ダウンロード</a></li>
	<li>JSON API
		<ul>
		<li><a href="index.html#encoder">JSONエンコーダー</a></li>
		<li><a href="index.html#decoder">JSONデコーダー</a></li>
		<li><a href="index.html#usage_advanced">高度な使い方</a></li>
		</ul>
	</li>
	<li>Web サービス API
		<ul>
		<li><a href="webservice.html">基本的な説明</a></li>
		<li><a href="webservice.html#rpcservlet">RPCサーブレット</a></li>
		<li><a href="webservice.html#restservlet">RESTサーブレット</a></li>
		<li><a href="webservice.html#dicontainer">DIコンテナ対応</a></li>
		<li><a href="webservice.html#gatewayfilter">Gatewayフィルタ</a></li>
		</ul>
	</li>
	<li>API リファレンス
		<ul>
		<li><a href="java/api/index.html">javadoc</a></li>
		<li><a href="as3/api/index.html">asdoc</a></li>
		</ul>
	</li>
	<li>旧バージョン
		<ul>
		<li><a href="http://jsonic.sourceforge.jp/1.2/index.html">version 1.2</a></li>
		<li><a href="http://jsonic.sourceforge.jp/1.1/index.html">version 1.1</a></li>
		<li><a href="http://jsonic.sourceforge.jp/1.0/index.html">version 1.0</a></li>
		</ul>
	</li>
	<li><a href="index.html#license">ライセンス</a></li>
	<li><a href="index.html#report">バグ・要望の報告先</a></li>
	<li><a href="index.html#releasenote">リリースノート</a></li>
</ul>
</div>

<div class="head">
<div class="subtitle">- simple json encoder/decoder for java</div>
<div class="sf"><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=2893" width="96" height="31" style="border-width:0px;" alt="SourceForge.jp" /></a></div>
<div class="bar">&nbsp;</div>
</div>

<div class="main">

<h2 id="webservice" style="margin-top: 5px;">基本的な説明</h2>

<p>JSONICには、JSONを使ったWebサービスが簡単に構築できるサーブレットが二種類用意されています。</p>

<table class="table" summary="サーブレットの種類">
<tr><th style="width: 20%">サーブレット</th><th style="width: 80%">説明</th></tr>
<tr><td>RPCServlet</td><td><a href="http://json-rpc.org">JSON-RPC</a> <a href="http://json-rpc.org/wiki/specification">1.0</a>/<a href="http://groups.google.com/group/json-rpc/web/json-rpc-2-0">2.0</a> 仕様に対応したRPC(Remote Procedure Call)サービスを構築できます。</td></tr>
<tr><td>RESTServlet</td><td>GET/POST/PUT/DELETEなどHTTP Methodをベースに操作を行うRESTfullなWebサービスを構築できます。</td></tr>
</table>

<div class="warning">WebServiceServletは、JSONIC 1.3以降削除されました。今後はRESTServletおよびRPCServletを利用してください。</div>

<h2 id="rpcservlet">RPCサーブレット</h2>
<p>RPCサーブレットは、<a href="http://json-rpc.org/wiki/specification">JSON-RPC 1.0</a> および <a href="http://groups.google.com/group/json-rpc/web/json-rpc-2-0">JSON-RPC 2.0</a> の両方をサポートしたWEBサービス構築用サーブレットです。</p>

<h3>■ RPCサーブレットの概要</h3>

<p>RPCサーブレットを使うと、指定したパスに対しJSONをPOSTすることで、対象クラスのメソッドを呼び出すことができます（GET/PUT/DELETEは無効です）。paramsに指定された配列の値はメソッドの引数に指定された型に従い自動的に変換されます。なお、クラス名はUpperCamel、メソッド名はLowerCamelに自動的に変換されます。そして、実行後、戻り値がJSONに変換されクライアントに返されます。</p>
<pre class="console">
POST /rpc.json HTTP/1.0
...
Content-Type: application/json

{ "method": "class.method", "params": [ arg1, arg2, ... ], "id": request_id }
</pre>
<p>class, methodにはそれぞれ変数の値、argNにはメソッドの引数を設定してください。requesst_idには送受信の同期確認用のキーとしてnull以外の任意の値を設定してください（HTTPでは、送信と受信は同期処理ですのでほとんど意味はありませんが、省略すると通知(Notification)モードとなりレスポンスのメッセージボディが返されませんので必ず値を指定してください）。</p>
<p>例えば、mappingsに "/{package}/{class}.{ext}": "boo.${package}.${class}Service" という指定があった場合、 /foo/woo/rpc.jsonというパスに次のJSONがPOSTすると、boo.foo.woo.CalcServiceクラスのplusメソッドが呼び出されます。</p>
<pre class="console">
POST /foo/woo/rpc.json HTTP/1.0
...
Content-Type: application/json

{ "method": "calc.plus", "params": [1,2], "id": 1 }
</pre>
<p>boo.foo.woo.CalcServiceは次のように実装されていたとします。</p>
<pre class="source">
package boo.foo.woo;

public class CalcService {
    public int plus(int a, int b) {
        return a + b;
    }
}
</pre>
<p>この時、レスポンスのメッセージボディとしては次のような結果が返されます。</p>
<pre class="console">
HTTP/1.0 200 OK
...
Content-Type: application/json

{ "result": 3, "error": null, "id": 1 }
</pre>

<p>各パラメータの意味は次の通りです。</p>

<table class="table" summary="パラメータの意味">
<tr><th style="width: 10%">方向</th><th style="width: 10%">パラメータ</th><th style="width: 80%">説明</th></tr>
<tr><td rowspan="4">リクエスト</td><td>jsonrpc</td><td>JSON-RPC 2.0で接続する時のみ"2.0"を指定します。1.0で接続する時は指定しません。</td></tr>
<tr><td>method</td><td>メソッド名を指定します。パス変数で<code>class</code>が指定されている場合はメソッド名を、指定していない場合はクラス名とメソッド名を「<code>class.method</code>」の形式で指定する必要があります。なお、クラス名はパッケージを含んだ完全名ではなく、後述で設定するマッピングに対応した名前を指定してください。</td></tr>
<tr><td>params</td><td>パラメータを指定します。JSON arrayを指定した場合はメソッドの引数に指定された型に変換され引渡されます。JSON-RPC 2.0ではJSON objectを指定できますが、その場合は、第一引数に指定された型に変換され引渡されます。</td></tr>
<tr><td>id</td><td>設定するとレスポンスのid値として同じ値が戻されます。なお、JSON-RPC 1.0ではidがnullの時、2.0ではidを省略すると通知(Notification)モードとなりレスポンスのメッセージボディが返されませんので必ず値を指定してください。</td></tr>
<tr><td rowspan="4">レスポンス</td><td>jsonrpc</td><td>JSON-RPC 2.0で接続した時のみ"2.0"が返されます。1.0では設定されません。</td></tr>
<tr><td>result</td><td>成功した時には、結果が設定されます。JSON-RPC 2.0では成功した時のみ設定されます。</td></tr>
<tr><td>error</td><td>エラーの時にはエラー情報が設定されます。JSON-RPC 2.0ではエラーの時のみ設定されます。</td></tr>
<tr><td>id</td><td>リクエストで設定されたidの値がそのまま戻されます。</td></tr>
</table>

<h3>■ エラーオブジェクト</h3>

<p>RPCサーブレットでエラーが発生した場合にはレスポンスのメッセージボディでクライアントに通知されます。ステータスコードは、エラーの有無に関わらず200 OKが返されます。</p>
<pre class="console">
HTTP/1.0 200 OK
...
Content-Type: application/json

{ "result": null, "error": { "code": -32600, "message": "Invalid Request.", "data": {} }, "id": 1 }
</pre>
<p>errorの値には code, message, dataの三つのキーを持つJSON objectが設定されます。codeとmessageについては次表を参照してください。dataには投げられた例外のプロパティがセットされます（ただし、Throwableクラスのプロパティは除外されます）。</p>
<table class="table" summary="RPC エラー一覧">
<tr><th>エラー内容</th><th>HTTP Status Code</th><th>Message Body</th></tr>
<tr>
<td>JSONリクエストがJSON-RPCのリクエストとして不正</td>
<td>200&nbsp;OK</td>
<td><pre style="margin:0;">{
  "code": -32600,
  "message": "Invalid Request."
}</pre></td>
</tr>
<tr>
<td>methodで指定したクラス/メソッドが見つからない<sup>(※1)</sup></td>
<td>200&nbsp;OK</td>
<td><pre style="margin:0;">{
  "code": -32601,
  "message": "Method not found."
}</pre></td>
</tr>
<tr>
<td>paramsが不適切<sup>(※2)</sup></td>
<td>200&nbsp;OK</td>
<td><pre style="margin:0;">{
  "code": -32602,
  "message": "Invalid params."
}</pre></td>
</tr>
<tr>
<td>JSONの解析に失敗した</td>
<td>200&nbsp;OK</td>
<td><pre style="margin:0;">{
  "code": -32700,
  "message": "Parse error.",
  "data": {
    "columnNumber": エラーが発生した列番号,
    "errorOffset": エラーが発生した位置,
    "lineNumber": エラーが発生した行番号
  }
}</pre></td>
</tr>
<tr>
<td>errorsに設定された例外が発生した</td>
<td>200&nbsp;OK</td>
<td><pre style="margin:0;">{
  "code": errorsで設定した値,
  "message": 例外オブジェクトの単純クラス名 + ": " + getMessage()の値,
  "data": 例外オブジェクト（ただし、Throwableクラスに定義されているプロパティは除く）
}</pre></td>
</tr>
<tr>
<td>その他の例外が発生した</td>
<td>200&nbsp;OK</td>
<td><pre style="margin:0;">{
  "code": -32603,
  "message": "Internal error."
}</pre></td>
</tr>
</table>
<div class="caption">(※1) クラス/メソッドが見つからなかった時だけでなく、メソッドからIllegalStateExceptionやUnsupportedOperationExceptionが投げられた場合も同じエラーが返されます。</div>
<div class="caption">(※2) Convertに失敗した場合だけでなく、メソッドからIllegalArgumentExceptionが投げられた場合も同じエラーが返されます。</div>

<h3 id="configuration">■ 設定方法</h3>
<p>RPC サーブレットは、web.xmlにRPCServletを指定し、パスとClassのマッピングなどの設定を行うだけです。</p>
<pre class="source">
<span class="elem">&lt;servlet&gt;</span>
    <span class="elem">&lt;servlet-name&gt;</span>rpcServlet<span class="elem">&lt;/servlet-name&gt;</span>
    <span class="elem">&lt;servlet-class&gt;</span>net.arnx.jsonic.web.RPCServlet<span class="elem">&lt;/servlet-class&gt;</span>
    <span class="elem">&lt;init-param&gt;</span>
        <span class="elem">&lt;param-name&gt;</span>config<span class="elem">&lt;/param-name&gt;</span>
        <span class="elem">&lt;param-value&gt;</span>
        {
            "debug": true,
            "mappings": {
                "/{package}/{class}.json": "sample.web.${package}.service.${class}Service",
                "/rpc.json": "sample.${class}Service"
            }
        }
        <span class="elem">&lt;/param-value&gt;</span>
    <span class="elem">&lt;/init-param&gt;</span>
<span class="elem">&lt;/servlet&gt;</span>

<span class="elem">&lt;servlet-mapping&gt;</span>
    <span class="elem">&lt;servlet-name&gt;</span>rpcServlet<span class="elem">&lt;/servlet-name&gt;</span>
    <span class="elem">&lt;url-pattern&gt;</span>*.json<span class="elem">&lt;/url-pattern&gt;</span>
<span class="elem">&lt;/servlet-mapping&gt;</span>
</pre>
<p>configで設定できる値は次の通りです（errorsを除き、RESTServletと同じです）。</p>
<table class="table" summary="Config設定">
<tr><th style="width:15%">キー</th><th style="width:30%">値型</th><th style="width:55%">説明</th></tr>
<tr><td>container</td><td><code>net.arnx.jsonic.web.Container</code></td><td>クラスのインスタンスを取得するためのコンテナを設定します。デフォルトは、<code>net.arnx.jsonic.web.Container</code>です。</td></tr>
<tr><td>encoding</td><td><code>java.lang.String</code></td><td>Request/Responseの文字エンコーディングを設定します。デフォルトはUTF-8です。</td></tr>
<tr><td>expire</td><td><code>java.lang.Boolean</code></td><td>クライアントキャッシュを抑制するHTTPヘッダを出力します(<code>Cache-Control:&nbsp;no-cache, Pragma:&nbsp;no-cache, Expires:&nbsp;Tue,&nbsp;29&nbsp;Feb&nbsp;2000&nbsp;12:00:00&nbsp;GMT</code>)。デフォルトはtrueです。</td></tr>
<tr><td>debug</td><td><code>java.lang.Boolean</code></td><td>デバッグモードの有効/無効を切り替えます。デフォルトはfalseです。</td></tr>
<tr><td>mappings</td><td><code>java.util.Map&lt;String, String&gt;</code></td><td>URLパスとクラスのマッピングを行います。
パス中の<code>{<i>name</i>}</code>で囲まれた部分はパス変数として、クラス名の<code>${<i>name</i>}</code>に置換されたりメソッドの引数に設定されます<sup>(※3)</sup>。また、<code>{<i>name</i>:<i>regex</i>}</code>と記載することで、変数の定義を設定することができます（definitionsより優先します）。</td></tr>
<tr><td>definitions</td><td><code>java.util.Map&lt;String, Pattern&gt;</code></td><td>mappings中の変数の定義を正規表現で設定します。設定されない場合は<code>[^/().]+</code>が設定されたものと扱われます。</td></tr>
<tr><td>init</td><td><code>java.lang.String</code></td><td>処理の実行前に呼び出されるメソッド名を設定します。デフォルトは<code>"init"</code>です。</td></tr>
<tr><td>destroy</td><td><code>java.lang.String</code></td><td>処理の実行後に呼び出されるメソッド名を設定します。デフォルトは<code>"destroy"</code>です。</td></tr>
<tr><td>processor</td><td><code>net.arnx.jsonic.JSON</code></td><td>処理に使用するJSONクラスを設定します。デフォルトではThrowableのメソッドのみ無視するJSONクラスが設定されます。</td></tr>
<tr><td>namingConversion</td><td>boolean</td><td>呼び出し時のクラス名、メソッド名の変換を行うか否か設定します。デフォルトはtrueです。</td></tr>
<tr><td>errors</td><td><code>java.util.Map&lt;Class&lt; extends Exception&gt;, Integer&gt;</code></td><td>Exceptionクラスとエラーコードのマッピングを行います（継承したクラスも対象になります）。</td></tr>
</table>
<div class="caption">
(※3) 変数名のうち、classとpackageだけは特殊な扱いがされます。デフォルトでは、class変数中の文字列はUpperCamelに変換され、package変数中の「/」は「.」に変換されます。
また、URLパスにはコンテキストパスを含める必要はありません。
</div>

<h2 id="restservlet">RESTサーブレット</h2>
<p>RESTサーブレットは、GET/POST/PUT/DELETEなどHTTP Methodをベースに操作を行うRESTfullなWebサービス構築用サーブレットです。</p>

<h3>■ RESTサーブレットの概要</h3>

<p>RESTサーブレットを使うと、GET/POST/PUT/DELETEなどのHTTP Methodに従って、対象となったクラスのメソッドが呼び出されます。その後、戻り値がJSONに変換されクライアントに返されます。</p>
<p>HTTP MethodとJava メソッド名のデフォルトのマッピングは次の通りです<sup>(※4)</sup>。</p>
<table class="table" summary="REST Method マッピング">
<tr><th>HTTP Method</th><th>Java メソッド名</th><th>引数</th></tr>
<tr><td>GET</td><td>find</td><td>リクエストパラメータを<code>.</code>あるいは<code>[]</code>で区切られた階層構造とみなし引数の型に従い変換し設定されます。</td></tr>
<tr><td>POST</td><td>create</td><td rowspan="3">Content-Typeが「<code>application/json</code>」の時は、メッセージボディのJSON文字列を引数の型に従い変換し設定されます。<br />
Content-Typeが「<code>application/x-www-form-urlencoded</code>」の時はリクエストパラメータを<code>.</code>あるいは<code>[]</code>で区切られた階層構造とみなし引数の型に従い変換し設定されます。</td></tr>
<tr><td>PUT</td><td>update</td></tr>
<tr><td>DELETE</td><td>delete</td></tr>
</table>
<div class="caption">
(※4) ブラウザなどでは、PUT/DELETEが使えない場合があります。そのような場合の代替手段として、クエリ変数に「_method=HTTP Method名」を指定することもできます。<br />
</div>

<p>例えば、mappingsに <code>"/{package}/{class}.{ext}": "boo.${package}.${class}Service"</code> という指定があった場合、 <code>/foo/woo/resource.json</code>というパスをGETすると、<code>boo.foo.woo.ResourceService</code>クラスの<code>find</code>が呼び出されます。</p>
<pre class="console">
GET /foo/woo/resource.json HTTP/1.0
...
</pre>
<p>boo.foo.woo.ResourceServiceは次のように実装されていたとします。</p>
<pre class="source">
package boo.foo.woo;

public class ResourceService {
	public Object find(Map params) {
	    List&lt;Map&gt; list = Database.select("select * from resource", params);
	    return list;
	}
}
</pre>
<p>この時、レスポンスのメッセージボディとしては次のような結果が返されるかもしれません<sup>(※5)</sup>。</p>
<pre class="console">
HTTP/1.0 200 OK
...
Content-Type: application/json

[
  { "id": 1, "name": "boo", "age": 10 },
  { "id": 2, "name": "foo", "age": 12 },
  { "id": 3, "name": "woo", "age": 14 }
]
</pre>
<div class="caption">
(※5) JSONはobjectかarrayより始まる必要があるため、それ以外の要素に変換される型の戻り値（例えば、boolean/int/Dateなど）の場合にはSC_NO_CONTENTが返されます。<br />
</div>
<p>引数には送信されたデータが指定された型に従い変換され設定されます。引数への設定は、データの送信方法によって次のような違いがあります。</p>
<table class="table" summary="引数設定一覧">
<tr><th style="width: 15%">Content&nbsp;Type</th><th style="width: 15%">Request&nbsp;Type</th><th style="width: 70%">説明</th></tr>
<tr><td rowspan="2">application/json</td><td>JSON object</td><td>パス変数、リクエストパラメータの順に追加されたJSON objectが設定されます（同じキーが複数出現した場合は配列化されます）。</td></tr>
<tr><td>JSON array</td><td>送信されたJSON arrayを引数リストとして扱います。なお、第一引数がJSON objectである場合には、上記と同様にパス変数、リクエストパラメータ、第一引数の順でデータが追加されます。
その他の型や第二引数以降はそのまま設定されます。</td></tr>
<tr><td colspan="2">URLパラメータ<br />application/x-www-form-urlencoded</td><td>リクエストパラメータを<code>.</code>あるいは<code>[]</code>で区切られた階層構造とみなし変換したオブジェクトが設定されます。</td></tr>
</table>

<p>さきほどの例でidが3のデータを指定する場合は次のようにします。</p>
<pre class="console">
GET /foo/woo/resource.json?id=3 HTTP/1.0
...
</pre>
<p>この時、レスポンスのメッセージボディとしては次のような結果が返されるかもしれません。</p>
<pre class="console">
HTTP/1.0 200 OK
...
Content-Type: application/json

[
  { "id": 3, "name": "woo", "age": 14 }
]
</pre>
<p>よりREST的にしたいのであれば、mappingsのパスに <code>/{package}/{class}/{id}.{ext}</code> を定義するなどしてパラメータをURLに含めることなどもできます。</p>

<h3>■ エラーオブジェクト</h3>

<p>エラーの発生はHTTP Status Codeによりクライアントに通知されます。</p>
<table class="table" summary="RPC エラー一覧">
<tr><th>エラー内容</th><th>HTTP Status Code</th><th>Message Body</th></tr>
<tr>
<td>クラス/メソッドが見つからない<sup>(※6)</sup></td>
<td>404&nbsp;Not&nbsp;found</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>送信されたJSONの解析/変換に失敗した</td>
<td>400&nbsp;Bad&nbsp;request</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>errorsに設定された例外が発生した</td>
<td>errorsで設定したステータスコード</td>
<td><pre style="margin:0;">{
  "name": 例外オブジェクトの単純クラス名
  "message": 例外オブジェクトのgetMessage()の値,
  "data": 例外オブジェクト（ただし、Throwableクラスに定義されているプロパティは除く）
}</pre></td>
</tr>
<tr>
<td>その他の例外が発生した</td>
<td>500&nbsp;Internal Server Error</td>
<td>&nbsp;</td>
</tr>
</table>
<div class="caption">(※6) クラス/メソッドが見つからなかった時だけでなく、メソッドからIllegalStateExceptionやUnsupportedOperationExceptionが発生した場合も同じエラーが返されます。</div>
<div class="caption">(※7) メソッドからIllegalStateException、UnsupportedOperationExceptionが発生した場合は除きます。</div>

<h3 id="configuration">■ 設定方法</h3>
<p>REST サーブレットは、web.xmlにRESTServletを指定し、パスとClassのマッピングなどの設定を行うだけです。</p>
<pre class="source">
<span class="elem">&lt;servlet&gt;</span>
    <span class="elem">&lt;servlet-name&gt;</span>restServlet<span class="elem">&lt;/servlet-name&gt;</span>
    <span class="elem">&lt;servlet-class&gt;</span>net.arnx.jsonic.web.RESTServlet<span class="elem">&lt;/servlet-class&gt;</span>
    <span class="elem">&lt;init-param&gt;</span>
        <span class="elem">&lt;param-name&gt;</span>config<span class="elem">&lt;/param-name&gt;</span>
        <span class="elem">&lt;param-value&gt;</span>
        {
            "debug": true,
            "mappings": {
                "/{package}/{class}/{id:[0-9]+}.json": "sample.web.${package}.service.${class}Service",
                "/{package}/{class}.json": "sample.web.${package}.service.${class}Service",
                "/{class}.json": "sample.${class}Service"
            }
        }
        <span class="elem">&lt;/param-value&gt;</span>
    <span class="elem">&lt;/init-param&gt;</span>
<span class="elem">&lt;/servlet&gt;</span>

<span class="elem">&lt;servlet-mapping&gt;</span>
    <span class="elem">&lt;servlet-name&gt;</span>restServlet<span class="elem">&lt;/servlet-name&gt;</span>
    <span class="elem">&lt;url-pattern&gt;</span>*.json<span class="elem">&lt;/url-pattern&gt;</span>
<span class="elem">&lt;/servlet-mapping&gt;</span>
</pre>
<p>configで設定できる値は次の通りです（method, verbを除き、RPCServletと同じです）。</p>
<table class="table" summary="Config設定">
<tr><th style="width:15%">キー</th><th style="width:30%">値型</th><th style="width:55%">説明</th></tr>
<tr><td>container</td><td><code>net.arnx.jsonic.web.Container</code></td><td>クラスのインスタンスを取得するためのコンテナを設定します。デフォルトは、<code>net.arnx.jsonic.web.Container</code>です。</td></tr>
<tr><td>encoding</td><td><code>java.lang.String</code></td><td>Request/Responseの文字エンコーディングを設定します。デフォルトはUTF-8です。</td></tr>
<tr><td>expire</td><td><code>java.lang.Boolean</code></td><td>クライアントキャッシュを抑制するHTTPヘッダを出力します(<code>Cache-Control:&nbsp;no-cache, Pragma:&nbsp;no-cache, Expires:&nbsp;Tue,&nbsp;29&nbsp;Feb&nbsp;2000&nbsp;12:00:00&nbsp;GMT</code>)。デフォルトはtrueです。</td></tr>
<tr><td>debug</td><td><code>java.lang.Boolean</code></td><td>デバッグモードの有効/無効を切り替えます。デフォルトはfalseです。</td></tr>
<tr><td>mappings</td><td><code>java.util.Map&lt;String, String&gt;</code></td><td>URLパスとクラスのマッピングを行います。
パス中の<code>{<i>name</i>}</code>で囲まれた部分はパス変数として、クラス名の<code>${<i>name</i>}</code>に置換されたりメソッドの引数に設定されます<sup>(※8)</sup>。また、<code>{<i>name</i>:<i>regex</i>}</code>と記載することで、変数の定義を設定することができます（definitionsより優先します）。</td></tr>
<tr><td>definitions</td><td><code>java.util.Map&lt;String, Pattern&gt;</code></td><td>mappings中の変数の定義を正規表現で設定します。設定されない場合は<code>[^/().]+</code>が設定されたものと扱われます。</td></tr>
<tr><td>init</td><td><code>java.lang.String</code></td><td>処理の実行前に呼び出されるメソッド名を設定します。デフォルトは<code>"init"</code>です。</td></tr>
<tr><td>destroy</td><td><code>java.lang.String</code></td><td>処理の実行後に呼び出されるメソッド名を設定します。デフォルトは<code>"destroy"</code>です。</td></tr>
<tr><td>processor</td><td><code>net.arnx.jsonic.JSON</code></td><td>処理に使用するJSONクラスを設定します。デフォルトではThrowableのメソッドのみ無視するJSONクラスが設定されます。</td></tr>
<tr><td>namingConversion</td><td>boolean</td><td>呼び出し時のクラス名、メソッド名の変換を行うか否か設定します。デフォルトはtrueです。</td></tr>
<tr><td>errors</td><td><code>java.util.Map&lt;Class&lt; extends Exception&gt;, Integer&gt;</code></td><td>ExceptionクラスとHTTP Status Codeのマッピングを行います（継承したクラスも対象になります）。</td></tr>
<tr><td>method</td><td><code>java.util.Map&lt;String, String&gt;</code></td><td>HTTP Methodに対応するメソッド名を設定します。デフォルトは、<code>{ "GET": "find", "POST": "create", "PUT": "update", "DELETE": "delete" }</code>です。なお、パス変数にmethodが設定されている場合は無視されます。</td></tr>
<tr><td>verb</td><td><code>java.util.Set&lt;String&gt;</code></td><td>使用できるHTTP Methodを制限します。デフォルトは、<code>["HEAD", "GET", "POST", "PUT", "DELETE", "OPTIONS"]</code>です。HEADとOPTIONSを使う場合は、methodも対応付ける必要があります。</td></tr>
</table>
<div class="caption">
(※8) 変数名のうち、classとpackageだけは特殊な扱いがされます。デフォルトでは、class変数中の文字列はUpperCamelに変換され、package変数中の「/」は「.」に変換されます。また、URLパスにはコンテキストパスを含める必要はありません。
</div>

<p>なお、<code>method, verb</code>に関しては、<code>mappings</code>の各データ毎にも設定できます。その場合は次のようにマッピング先をJSON objectにします（マッピング先のプロパティ名は<code>target</code>にしてください）。</p>
<pre class="source">
    "mappings": {
        "/{package}/{class}.json": {
            "target": "sample.web.${package}.service.${class}Service",
            "method": { "GET": "print" },
            "verb": [ "GET" ]
        },
        ...
    }
</pre>

<h3 id="jsonp">■ パス変数によるメソッドの指定</h3>
<p>本来RESTでは、HTTP Methodで処理が決定されるためRPC的な任意のメソッド呼び出しは推奨されませんが、それでは不便が多いためパス変数に<code>method</code>を指定することで、任意のメソッド呼び出しを可能にしました。</p>
<p>例えば、次のように設定を行うと <code>/foo/calc.sum.json</code> を呼び出すと <code>sample.web.foo.service.CalcService</code> の <code>sum</code> メソッドが呼びだされます。</p>
<pre class="source">
    "mappings": {
        "/{package}/{class}.{method}.json": "sample.web.${package}.service.${class}Service"
    }
</pre>
<p>なお、このような使い方をする際は、verbと組み合わせてHTTP Methodを制限して使うことが推奨されます（GETで更新処理などを行うと、検索エンジンのクロールでデータが削除されるなどの問題が発生する可能性があります）。</p>

<h3 id="jsonp">■ JSONP <span class="subtitle">- JSON with padding</span></h3>
<p>HTTP MethodがGETの場合、リクエストパラメータとしてcallback=Function名を指定することでJSONPによる返答を返すことができるようになります。</p>
<pre class="source">
<span class="elem">&lt;script type="text/javascript"&gt;</span>
    function call(value) {
        alert(value);
    }
<span class="elem">&lt;/script&gt;</span>

...

<span class="elem">&lt;script type="text/javascript" src="http://host/hoge.json?callback=call"&gt;&lt;/script&gt;</span>
</pre>

<h3 id="response">■ JSON以外のレスポンス</h3>
<p>CSVやXMLなどJSON以外のレスポンスを返したい場合やリダイレクトしたい場合は、処理の最後でHttpServletResponse#flushBuffer()を実行して出力をコミットしてください。ステータスコードやコンテントタイプの設定、JSONの出力などJSONIC側の後続処理を抑制することができます。</p>
<pre class="source">
public class HogeService {
    <span class="comment">// 自動インジェクション</span>
    public HttpServletResponse response;
    
    <span class="comment">// CSVを出力する</span>
    public void print() throws IOException {
        response.setCharcterEncoding("MS932");
        PrintWriter writer = response.getWriter();
        writer.write("a,b,c\r\n");
        
        <span class="comment">// バッファをフラッシュして、出力を確定させる</span>
        <span class="elem">response.flushBuffer();</span>
    }
}
</pre>

<h2 id="dicontainer">DIコンテナ対応</h2>
<p>RPCサーブレット、RESTサーブレットは、内部のコンテナを切り替えることで呼び出し対象のインスタンスを任意のDIコンテナにて管理することが可能です。</p>
<p>JSONICでは、<a href="http://www.seasar.org/">Seasar2</a>、<a href="http://www.springframework.org/">Spring Framework</a>、<a href="http://code.google.com/p/google-guice/">Google Guice</a>に対応したContainerを標準添付しています（※1.2よりパッケージ名が変更されています。ご注意ください）。このContainerを利用すると、DI Container上で管理されているコンポーネントをWebServiceとして利用することができるようになります。</p>

<pre class="source">
<span class="elem">&lt;servlet&gt;</span>
    <span class="elem">&lt;servlet-name&gt;</span>rpcServlet or restServlet<span class="elem">&lt;/servlet-name&gt;</span>
    <span class="elem">&lt;servlet-class&gt;</span>net.arnx.jsonic.web.RPCServlet or RESTServlet<span class="elem">&lt;/servlet-class&gt;</span>
    <span class="elem">&lt;init-param&gt;</span>
        <span class="elem">&lt;param-name&gt;</span>config<span class="elem">&lt;/param-name&gt;</span>
        <span class="elem">&lt;param-value&gt;</span>
          <span class="comment">// "container": (net.arnx.jsonic.web.Containerを実装したクラス)</span>
          <span class="comment">// Seasar2対応Container</span>
          "container": "net.arnx.jsonic.web.extension.S2Container" 
          <span class="comment">// Spring Framework対応Container</span>
          "container": "net.arnx.jsonic.web.extension.SpringContainer"
          <span class="comment">// Google Guice対応Container</span>
          "container": "net.arnx.jsonic.web.extension.GuiceContainer"
          ...
        <span class="elem">&lt;/param-value&gt;</span>
    <span class="elem">&lt;/init-param&gt;</span>
<span class="elem">&lt;/servlet&gt;</span>
</pre>

<p>デフォルトでは最低限の機能のみ持つnet.arnx.jsonic.web.Containerが使われます。このコンテナが持つ機能は次の通りです。</p>
<ul>
<li>オブジェクトはClass#newInstance()により毎回生成されます。</li>
<li>ログは、ServletContext#log()を使って書き出されます。</li>
<li>呼び出し対象となるクラスにinitあるいはdestroyという名前のメソッドがある場合、処理の前後に呼び出します（この機能は全コンテナ共通です）。<sup>(※9)</sup></li>
<li>JSPの暗黙オブジェクトライクなパブリックフィールドベースの簡易DIを提供します。</li>
</ul>
<div class="caption">(※9) 呼び出されるメソッド名は設定で変更可能です。</div>

<p>暗黙オブジェクトは以下のように設定してください。クラスだけでなくフィールド名も合わせる必要があります（デフォルトコンテナのみの機能です）。</p>
<pre class="source">
public class HogeService {
    public ServletConfig config;
    public ServletContext application;
    public HttpServletRequest request;
    public HttpServletResponse response;
    public HttpSession session;
}
</pre>
<p>コンテナ自身にHttpServletRequestとHttpServletResponseのDI機能がないSpringContainerに関しては、setterによるインジェクション機能を提供しています（下記例を参照）。</p>
<pre class="source">
public class SpringDrivenService {
    <span class="comment">// setterを用意すると自動で挿入します。プロパティ名を一致させる必要はありません。</span>
    public void setRequest(HttpServletRequest request) {
        ...
    }
    
    public void setResponse(HttpServletResponse response) {
        ...
    }
}
</pre>

<h3>処理エラーの取り扱い</h3>
<p>処理でエラーが発生した場合、専用のログを取ったり、、トランザクションをロールバックしたいなどあるかもしれません。その場合は、コンテナを継承してexecuteメソッドをオーバーライドします。</p>
<pre class="source">
public class TransactionalContainer extends Container {
    ...

    <span class="comment">// 処理実行時によばれます。</span>
    public Object execute(JSON json, Object component, Method method, List&lt;?&gt; params) throws Exception {
        Object ret = null;
        try {
            ret = super.execute(json, component, method, params);
            tx.commit();
        } catch (Exception e) {
            tx.rollback();
            throw e;
        }
    }
}
</pre>

<h2 id="gatewayfilter">Gatewayフィルタ</h2>
<p>JSONICでは、おまけ機能としてJSONを使ってServletで良く使う各種の機能を実装したFilterを提供しています。JSONICの書式を使えるため手軽に設定が可能です。</p>
<p>最初にマッチしたパスの設定が使われますが、そこで設定が行われなわれていない場合、ルートの設定が初期値として利用されます。パスには正規表現が利用できます。</p>
<pre class="source">
<span class="elem">&lt;filter&gt;</span>
    <span class="elem">&lt;filter-name&gt;</span>Gateway Filter<span class="elem">&lt;/filter-name&gt;</span>
    <span class="elem">&lt;filter-class&gt;</span>net.arnx.jsonic.web.GatewayFilter<span class="elem">&lt;/filter-class&gt;</span>
    <span class="elem">&lt;init-param&gt;</span>
        <span class="elem">&lt;param-name&gt;</span>config<span class="elem">&lt;/param-name&gt;</span>
        <span class="elem">&lt;param-value&gt;</span>
            <span class="comment">// 共通設定</span>
            encoding: 'UTF-8'          <span class="comment">// 文字コード設定</span>
            locale: 'en'               <span class="comment">// Responseのロケールを設定</span>
            compression: true          <span class="comment">// GZip圧縮</span>
            
            <span class="comment">// 拡張子がjsonのパスを対象</span>
            '.+\.json': {
                expire: true           <span class="comment">// クライアントキャッシュを無効化</span>
            }
            
            <span class="comment">// 例：日本向け設定</span>
            '/ja/([^.]+)': {
                forward: '/$1.json'     <span class="comment">// JSON Web Serviceに転送</span>
                encoding: 'SHIFT_JIS'
                expire: true
                locale: 'ja-JP'
                access: ['jpuser']    <span class="comment">// アクセス可能なロール</span>
            }
        <span class="elem">&lt;/param-value&gt;</span>
    <span class="elem">&lt;/init-param&gt;</span>
<span class="elem">&lt;/filter&gt;</span>

<span class="elem">&lt;filter-mapping&gt;</span>
    <span class="elem">&lt;filter-name&gt;</span>Gateway Filter<span class="elem">&lt;/filter-name&gt;</span>
    <span class="elem">&lt;url-pattern&gt;</span>/*<span class="elem">&lt;/url-pattern&gt;</span>
<span class="elem">&lt;/filter-mapping&gt;</span>
</pre>
<p>configで設定できる値は次の通りです。なお、これらの設定はフィルタの設定に関わらず一度だけしか適用されません。</p>
<table class="table" summary="Config設定">
<tr><th>キー</th><th>値型</th><th>説明</th></tr>
<tr><td>encoding</td><td><code>java.lang.String</code></td><td>Request/Responseの文字エンコーディングを設定します。デフォルトはnullです。</td></tr>
<tr><td>compression</td><td><code>java.lang.Boolean</code></td><td>クライアントから<code>Accept-Encoding: gzip or x-gzip</code>が送られる場合、ResponseをGZip圧縮します。</td></tr>
<tr><td>expire</td><td><code>java.lang.Boolean</code></td><td>クライアントキャッシュを抑制するHTTPヘッダを出力します(<code>Cache-Control:&nbsp;no-cache, Pragma:&nbsp;no-cache, Expires:&nbsp;Tue,&nbsp;29&nbsp;Feb&nbsp;2000&nbsp;12:00:00&nbsp;GMT</code>)。デフォルトは<code>false</code>です。</td></tr>
<tr><td>forward</td><td><code>java.lang.String</code></td><td>指定されたパスに転送します（パスはコンテキストパス以下を指定します。正規表現の置換変数が利用できます）。</td></tr>
<tr><td>access</td><td><code>java.util.Set&lt;String&gt;</code></td><td>アクセス可能なアプリケーションロールを配列で指定します（認証そのものはコンテナの機能などを使う必要があります）。</td></tr>
<tr><td>locale</td><td><code>java.util.Locale</code></td><td>Responseのロケールを設定します。</td></tr>
</table>
<p>なお、encodingとexpireに関してはRPCサーブレットやRESTサーブレット側にも同様の設定が用意されており、そちら側の設定が優先されます。</p>

<hr style="margin-top: 30px;" />
<div class="copyright">Copyright (C) 2007-2010 Hidekatsu Izuno All right reserved.</div>
</div>
</body>
</html>