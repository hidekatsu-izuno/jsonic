<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>jsonic - simple json encoder/decoder for java</title>
<style type="text/css">
	html { overflow-x: hidden; height:100%; }
	body { width: 100%; height: 100%; margin: 0px; padding: 0px; font: 10pt sans-serif; z-index: 1; }
	.sidebar { width: 150px; height: 100%;  margin: 0px; padding: 0px; background: white;
		position: fixed; top: 0px; left: 0px; bottom: 0px; overflow: hidden; z-index: 2; }
	.title { width: 150px; height: 46px; margin: 0px; padding: 0px; }
	.title a { position: absolute; top: 8px; left: 5px; overflow: hidden; }
	.menu { width: 150px; margin: 0px; padding: 0px; }
	.head { width: 100%; margin: 0px 150px 0px 0px; padding: 0px; }
	.head .subtitle { position: absolute; top: 18px; left: 150px; }
	.sf { height: 46px; margin: 0px; padding: 0px; }
	.sf a { position: absolute; top: 8px; right: 20px; }
	.main { margin: 0px 0px 0px 150px; padding: 0px; }
	.bar { margin: 0px; padding: 0px 10px; }
	
	.main { line-height: 1.5; border-left: 1px solid silver; padding: 15px 20px 15px 20px; }
	.title { font: bold 20pt sans-serif; color: #6699FF; }
	.title a { color: #6699FF; text-decoration: none; }
	.subtitle { font: italic 12pt sans-serif; color: gray; }
	.bar { color: white; background: gray; font: bold 8pt sans-serif; text-align: right; }
	.menu { margin: 15px 0px 15px 15px; padding: 0px; list-style-type: none; }
	.menu ul { margin: 0px; padding: 0px 0px 0px 20px; font-size: 8pt; list-style-image: url(images/marker.jpg); }
	.menu li { line-height: 1.5; }
	.menu li a { text-decoration: none; }
	.main ul { list-style-image: url(images/marker.jpg); }
	h2 { font: bold 12pt sans-serif; margin: 30px 0px 10px 0px; border: 1px solid silver; padding: 1px;
		background-image: url(images/header.jpg); background-position: center center; line-height: 1.0; }
	h3 { font: bold 11pt sans-serif; border-bottom: 1px solid gray; margin: 30px 0px 12px 0px;
		padding: 1px; line-height: 1.0; }
	h3 .subtitle { font: 9pt sans-serif; padding: 1px; line-height: 1.0; }
	a { color: darkblue; }
	p { margin: 0px 0px 1em 0px; padding: 0px; }
	.source { border: 1px solid silver; font: 9pt monospace; padding: 16px; background-color: #E0FFFF; }
	.comment { color: #0066FF; font-family: monospace; }
	.em { font-weight: bold; color: #000099; font-family: monospace; }
	.elem { font-weight: bold; color: #000099; }
	.table { border: 1px solid black; font: 9pt sans-serif; width: 100%; border-collapse: collapse; 
		margin: 0px 0px 1em 0px; }
	.table th { background-color: silver; border: 1px solid gray; white-space: nowrap; }
	.table td { border: 1px solid gray; padding: 2px 2px;}
	sup { font-size: 8pt; }
	.caption { font: 8pt sans-serif; margin: 10px; }
	.copyright { text-align: right; }
</style>
<!--[if IE 6]>
<style type="text/css">
	.sidebar { position: absolute; }
</style>
<![endif]--> 
</head>
<body>
<div class="sidebar">
<h1 class="title"><a href="index.html"><img src="images/jsonic_logo.jpg" width="136" height="34" alt="jsonic" style="vertical-align: -10px; border-width:0px;" /></a></h1>
<div class="bar">Version 1.2</div>
<ul class="menu">
	<li><a href="#introduction">JSONICとは</a></li>
	<li><a href="#download">ダウンロード</a></li>
	<li>使い方
		<ul>
			<li><a href="#usage_basic">基本的な使い方</a></li>
			<li><a href="#usage_advanced">高度な使い方</a></li>
			<li><a href="#webservice">Web Service Servlet</a></li>
			<li><a href="#as3">JSONIC for AS3</a></li>
		</ul>
	</li>
	<li>API Reference
		<ul>
			<li><a href="java/api/index.html">javadoc</a></li>
			<li><a href="as3/api/index.html">asdoc</a></li>
		</ul>
	</li>
	<li><a href="#license">ライセンス</a></li>
	<li><a href="#report">バグ・要望の報告先</a></li>
	<li><a href="#releasenote">リリースノート</a></li>
</ul>
</div>

<div class="head">
<div class="subtitle">- simple json encoder/decoder for java</div>
<div class="sf"><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=2893" width="96" height="31" style="border-width:0px;" alt="SourceForge.jp" /></a></div>
<div class="bar">&nbsp;</div>
</div>

<div class="main">

<h2 id="introduction" style="margin-top: 5px;">JSONICとは</h2>
<p>JSONICは、Java用のシンプルかつ高機能なJSONエンコーダー/デコーダーライブラリです。<br />
Java用のJSONライブラリはすでに多数存在しますが、JSONICは<a href="http://www.rfc-editor.org/rfc/rfc4627.txt">RFC 4627</a>に従った正式なJSON形式でのデコード/エンコードを行いながらも、プログラミング言語に依存する情報をJSON内に含めることなくPOJO(Plain Old Java Object)と自然な変換を行える点に特徴があります。</p>
<p>使い方も非常に簡単です。</p>
<pre class="source">
import net.arnx.jsonic.JSON;

<span class="comment">// POJOをJSONに変換します</span>
String text = <span class="em">JSON.encode(</span>new Hoge()<span class="em">)</span>;

<span class="comment">// JSONをPOJOに変換します</span>
Hoge hoge = <span class="em">JSON.decode(</span>text, Hoge.class<span class="em">)</span>;
</pre>

<h2 id="download">ダウンロード</h2>
<p><a href="http://sourceforge.jp/projects/jsonic">ダウンロードはこちらから</a>できます。なお、JSONICのビルド/実行には、Java 5.0以上が必要です。</p>
<div><script src="http://sourceforge.jp/projects/jsonic/files/compact.js" type="text/javascript" charset="utf-8"></script></div>

<h2 id="usage_basic">基本的な使い方</h2>

<p>通常の用途では、二つの静的メソッドencode/decodeだけ利用すれば事足ります。</p>
<h3>■ encodeメソッド <span class="subtitle">- POJOからJSONへの変換</span></h3>
<p>POJOからJSONに変換する場合は、encodeを使います。デフォルトでは、空白などを含まない可読性の低いJSONが出力されますが、二番目の引数をtrueにすることで可読性の高いJSONが出力されるようになります（Pretty Printモード）。</p>
<p>なお、JSONのフォーマット中に何らかの例外が発生した場合は、JSONExceptionでラップされ通知されます（Beanからの取得時に例外発生など）。</p>
<pre class="source">
<span class="comment">// 変換対象のPOJOを準備</span>
Hoge hoge = new Hoge();
hoge.number = 10;      <span class="comment">// public field</span>
hoge.setString("aaa"); <span class="comment">// public property</span>
hoge.setArray(new int[] {1, 2, 3});

<span class="comment">// POJOをJSONに変換します。戻り値は {"number":10,"string":"aaa","array":[1,2,3]}となります</span>
String text = <span class="em">JSON.encode(</span>hoge<span class="em">)</span>;

<span class="comment">// POJOを可読性の高いJSONに変換します。戻り値は次のような文字列になります
// {
//     "number": 10,
//     "string": "aaa",
//     "array": [1, 2, 3]
// }</span>
String text = <span class="em">JSON.encode(</span>hoge, true<span class="em">)</span>; 

<span class="comment">// Appendable(StringBuffer, Writerなど)やOutputStreamを出力先にすることもできます<sup>(※1)</sup></span>
<span class="em">JSON.encode(</span>hoge<span class="em">,</span> new FileWriter("hoge.txt")<span class="em">)</span>;
<span class="em">JSON.encode(</span>hoge<span class="em">,</span> new FileOutputStream("hoge.txt")<span class="em">)</span>;
</pre>
<div class="caption">(※1) OutputStreamを指定した場合に出力される文字コードはUTF-8固定となります。
また、close処理は自動では行われませんので必要に応じて別途行う必要があります。</div>

<p>POJOからJSONへの変換ルールは次の通りです。</p>
<table class="table" summary="POJOからJSONへの変換ルール">
<tr><th style="width: 50%">変換元（Java）</th><th style="width: 50%">変換先（JSON）</th></tr>
<tr><td>Map, DynaBean<sup>(※2)</sup></td><td rowspan="2">object</td></tr>
<tr><td>Object<sup>(※3)</sup></td></tr>
<tr><td>boolean[], short[], int[], long[], float[], double[], Object[]</td><td rowspan="4">array</td></tr>
<tr><td>Iterable (Collection, Listなど)</td></tr>
<tr><td>Iterator, Enumeration</td></tr>
<tr><td>java.sql.Array, java.sql.Struct</td></tr>
<tr><td>char[], CharSequence</td><td rowspan="3">string</td></tr>
<tr><td>char, Character</td></tr>
<tr><td>TimeZone, Pattern, File, URL, URI, Type, Member, Charset</td></tr>
<tr><td>byte[]</td><td>string (BASE64エンコード)</td></tr>
<tr><td>java.sql.RowId</td><td>string (シリアル化後、BASE64エンコード)</td></tr>
<tr><td>Locale</td><td>string (言語コード-国コードあるいは言語コード-国コード-バリアントコード)</td></tr>
<tr><td>InetAddress</td><td>string (IPアドレス)</td></tr>
<tr><td>byte, short, int, long, float, double</td><td rowspan="2">number<sup>(※4)</sup></td></tr>
<tr><td>Number</td></tr>
<tr><td>Date, Calendar</td><td>number (1970年からのミリ秒)</td></tr>
<tr><td>Enum</td><td>number (ordinalにより変換)</td></tr>
<tr><td>boolean, Boolean</td><td>true/false</td></tr>
<tr><td>null</td><td>null</td></tr>
</table>
<div class="caption">
(※2) DynaBeanを利用する場合、<a href="http://commons.apache.org/beanutils/">Commons BeanUtils</a>のjarファイルをクラスパスに追加する必要があります。リフレクションを利用して処理を行っているため、利用しない場合は特に含める必要はありません。<br />
(※3) 対象となるインスタンスをパブリック・getterメソッド、パブリック・フィールドの優先順で探索します。staticが付加されたメソッドやフィールド、transientが付加されたフィールドは対象となりません。<br />
(※4) NaN, Infinity, -Infinityに限りそれぞれ文字列"NaN", "Infinity", "-Infinity"に変換されます。
</div>
<p>また、org.w3c.dom.Document/ElementからJSONへの変換もサポートしています。詳しくは「<a href="#xmltojson">高度な使い方 - XMLからJSONへの変換</a>」の項をご覧ください。</p>
<p>なお、JSONはobjectかarrayで始まる必要があるため、直接、intやStringのインスタンスをencodeメソッドの引数に指定した場合エラーとなります。</p>

<h3>■ decodeメソッド <span class="subtitle">- JSONからPOJOへの変換</span></h3>
<p>JSONからPOJOに変換する場合は、decodeを使います。デフォルトでは、object, array, string, number, true/false, nullをHashMap, ArrayList, String, BigDecimal, Boolean, nullに変換しますが、二番目の引数に変換先のクラスを指定することでそのクラスのインスタンスにデータをセットして返してくれます。また、この処理はパブリック・フィールドやパブリック・プロパティ、配列やコレクションのデータを再帰的に辿り実行されますので、一般的なJavaBeansであればencodeして作られたJSONからの逆変換も可能です（Generics型にも対応しています）。</p>
<p>なお、JSON文字列が不正であったり、型の変換に失敗した場合はJSONExceptionが投げられます。</p>
<pre class="source">
<span class="comment">// JSONをPOJOに変換します。戻り値としてサイズが4のArrayListが返されます</span>
List list = (List)<span class="em">JSON.decode(</span>"[1, \"a\", {}, false]"<span class="em">)</span>;

<span class="comment">// JSONをHogeクラスのインスタンスに変換します（キャストは不要です）</span>
Hoge hoge = <span class="em">JSON.decode(</span>"{\"number\": 10, \"array\": [1, 2, 3]}", Hoge.class<span class="em">)</span>;

<span class="comment">// ReaderやInputStreamからJSONを読み込むことも可能です<sup>(※5)</sup></span>
Hoge hoge = <span class="em">JSON.decode(</span>new FileReader("hoge.txt")<span class="em">,</span> Hoge.class<span class="em">)</span>;
Hoge hoge = <span class="em">JSON.decode(</span>new FileInputStream("hoge.txt")<span class="em">,</span> Hoge.class<span class="em">)</span>;
</pre>
<div class="caption">(※5) InputStreamから読み込む場合の文字コードは、UTF-8/UTF-16BE/UTF-16LE/UTF-32BE/UTF-32LEから自動判別されます。
また、close処理は自動では行われませんので必要に応じて別途行う必要があります。</div>

<p>JSONからPOJOへの変換ルールは次の通りです。</p>
<table class="table" summary="JSONからPOJOへの変換ルール">
<tr><th style="width: 20%">変換元（JSON）</th><th style="width: 40%">指定された型</th><th style="width: 40%">変換先（Java）</th></tr>
<tr><td rowspan="4">object</td><td>なし, Object, Map</td><td>LinkedHashMap</td></tr>
<tr><td>SortedMap</td><td>TreeMap</td></tr>
<tr><td>その他のMap派生型</td><td>指定された型</td></tr>
<tr><td>その他の型</td><td>指定された型（パブリック・フィールド／プロパティに値をセット)<sup>(※6)</sup></td></tr>
<tr><td rowspan="9">array</td><td>なし, Object, Collection, List</td><td>ArrayList</td></tr>
<tr><td>Set</td><td>LinkedHashSet</td></tr>
<tr><td>SortedSet</td><td>TreeSet</td></tr>
<tr><td>その他のCollection派生型</td><td>指定された型</td></tr>
<tr><td>short[], byte[], int[], long[], float[], double[]<br />Object[]派生型</td><td>指定された型</td></tr>
<tr><td>Locale</td><td>Locale（「言語コード」「国コード」「バリアントコード」からなる配列とみなし変換）</td></tr>
<tr><td>Map</td><td>インデックスの値をキーとするLinkedHashMap</td></tr>
<tr><td>SortedMap</td><td>インデックスの値をキーとするTreeMap</td></tr>
<tr><td>その他のMap派生型</td><td>インデックスの値をキーとする指定された型のMap</td></tr>
<tr><td rowspan="16">string</td><td>なし, Object, CharSequence, String</td><td>String</td></tr>
<tr><td>char</td><td>char（幅0の時は'\u0000', 2文字以上の時は1文字目）</td></tr>
<tr><td>Character</td><td>Character（幅0の時はnull, 2文字以上の時は1文字目）</td></tr>
<tr><td>Appendable</td><td>StringBuilder</td></tr>
<tr><td>その他のAppendable派生型</td><td>指定された型（値をappend）</td></tr>
<tr><td>Enum派生型</td><td>指定された型（値をEnum.valueOfあるいはint型に変換後Enum.ordinal()で変換）</td></tr>
<tr><td>Date派生型,<br />Calendar派生型</td><td>指定された型（文字列をDateFormatで変換）</td></tr>
<tr><td>byte, short, int, long, float, double,<br />Byte, Short, Integer, Long, Float, Double,<br />BigInteger, BigDecimal</td><td>指定された型（文字列を数値とみなし変換）</td></tr>
<tr><td>byte[]</td><td>byte[]（文字列をBASE64とみなし変換）</td></tr>
<tr><td>Locale</td><td>Locale（文字列を「言語コード」「国コード」「バリアントコード」が何らかの句読文字で区切られているとみなし変換）</td></tr>
<tr><td>Pattern</td><td>Pattern（文字列をcompileにより変換）</td></tr>
<tr><td>Class, Charset</td><td>指定された型（文字列をforNameにより変換）</td></tr>
<tr><td>TimeZone</td><td>TimeZone（文字列をTimeZone.getTimeZoneを使い変換）</td></tr>
<tr><td>File, URI, URL</td><td>指定された型（文字列をコンストラクタの引数に指定し変換）</td></tr>
<tr><td>InetAddress</td><td>InetAddress（文字列をInetAddress.getByNameで変換）</td></tr>
<tr><td>boolean, Boolean</td><td>指定された型（"", "false", "no", "off", "NaN"の時false、その他の時true）</td></tr>
<tr><td rowspan="5">number</td><td>なし, Object, Number, BigDecimal</td><td>BigDecimal</td></tr>
<tr><td>byte, short, int, long, float, double,<br />Byte, Short, Integer, Long, Float, Double,<br />BigInteger</td><td>指定された型</td></tr>
<tr><td>Date派生型,<br />Calendar派生型</td><td>指定された型（数値を1970年からのミリ秒とみなし変換）</td></tr>
<tr><td>boolean, Boolean</td><td>指定された型（0以外の時true、0の時false）</td></tr>
<tr><td>Enum派生型</td><td>指定された型（int値をEnum.ordinal()に従い変換）</td></tr>
<tr><td rowspan="6">true/false</td><td>なし, Object, Boolean</td><td>Boolean</td></tr>
<tr><td>char, Character</td><td>指定された型（trueの時'1'、falseの時'0'）</td></tr>
<tr><td>float, double, Float, Double</td><td>指定された型（trueの時1.0、falseの時NaN）</td></tr>
<tr><td>byte, short, int, long,<br />Byte, Short, Integer, Long,<br />BigInteger</td><td>指定された型（trueの時1、falseの時0）</td></tr>
<tr><td>boolean</td><td>boolean</td></tr>
<tr><td>Enum派生型</td><td>指定された型（trueを1、falseを0とみなしEnum.ordinal()に従い変換）</td></tr>
<tr><td rowspan="4">null</td><td>なし, Object</td><td>null</td></tr>
<tr><td>byte, short, int, long, float, double</td><td>0</td></tr>
<tr><td>boolean</td><td>false</td></tr>
<tr><td>char</td><td>'\u0000'</td></tr>
</table>
<div class="caption">
(※6) 対象となるインスタンスに対しパブリックなsetterメソッド、パブリックなフィールドの優先順で探索します。
staticやtransientのメソッド/フィールドは対象となりません。
なお、プロパティ名は、単純比較が失敗した場合、LowerCamel記法に変換したものと比較します。
</div>

<h2 id="usage_advanced">高度な使い方</h2>
<p>JSONICでは、フレームワークなどでの利用を想定していくつかの便利な機能を用意しています。</p>
<ul>
<li><a href="#extends">継承による機能拡張</a></li>
<li><a href="#generics">総称型を指定してのdecode/parse</a></li>
<li><a href="#liberalparsing">柔軟な読み込み</a></li>
<li><a href="#innerclass">内部クラスを利用したエンコード/デコード</a></li>
<li><a href="#maxdepth">最大深度の設定</a></li>
<li><a href="#suppressnull">null値の抑制</a></li>
<li><a href="#xmltojson">XMLからJSONへの変換</a></li>
<li><a href="#jsonhint">変換時ヒントの付加</a></li>
<li><a href="#serializable">データの部分シリアル化</a></li>
</ul>

<h3 id="extends">■ 継承による機能拡張</h3>
<p>JSONICは、フレームワークでの利用を考慮しインスタンスを生成したり、継承して拡張することができるように設計してあります。
なお、インスタンスを生成して利用する場合は、encode/decodeメソッドの代わりにformat/parseメソッドを利用します。</p>
<pre class="source">
<span class="comment">// インスタンスを生成します</span>
<span class="em">JSON</span> json = new <span class="em">JSON()</span>;

<span class="comment">// POJOをJSONに変換します(encodeと同じ機能)</span>
String text = json<span class="em">.format(</span>new Hoge()<span class="em">)</span>;

<span class="comment">// POJOを可読性の高いJSONに変換します(Pretty Printモード)</span>
json.<span class="em">setPrettyPrint(</span>true<span class="em">)</span>;
String text = json<span class="em">.format(</span>new Hoge()<span class="em">)</span>;

<span class="comment">// JSONをPOJOに変換します(decodeと同じ機能)</span>
Map map = (Map)json<span class="em">.parse(</span>text<span class="em">)</span>;

<span class="comment">// JSONをHogeクラスのインスタンスに変換します(decodeと同じ機能)</span>
Hoge hoge = json<span class="em">.parse(</span>text, Hoge.class<span class="em">)</span>;
</pre>

<p>DIコンテナなどを使いインスタンスを生成したり、独自の変換を追加するために次のようなオーバーライド可能なメソッドが用意されています。</p>
<pre class="source">
JSON json = new JSON() {
  
  <span class="comment">// フォーマット可能なクラスに変換します（formatでのみ有効です）。
  // 例外が発生した場合、JSONExceptionでラップされ呼び出し元に通知されます。</span>
  protected <span class="em">Object preformat(Context context, Object value)</span> throws Exception {
    <span class="comment">// java.awt.geom.Point2DをJSON arrayにフォーマットする例です。</span>
    if (value instanceof Point2D) {
      Point2D p = (Point2D)value;
      List&lt;Double&gt; list = new ArrayList&lt;Double&gt;();
      list.add(p.getX());
      list.add(p.getY());
      return list;
    }
    return super.preformat(context, value);
  }
  
  <span class="comment">// 解析されたデータを指定したクラスに変換します（parseでのみ有効です）。
  // 例外が発生した場合、JSONExceptionでラップされ呼び出し元に通知されます。
  // さら下の階層を変換したい場合は、context.convert(キー, 値, 型)を呼び出してください。</span>
  protected <span class="em">&lt;T&gt; T postparse(Context context, Object value,
    Class&lt;? extends T&gt; c, Type t)</span> throws Exception {
    
    <span class="comment">// JSON arrayをjava.awt.geom.Point2Dに変換する例です。</span>
    if (Point2D.class.isAssignableFrom(c) &amp;&amp; value instanceof List) {
      List list = (List)value;
      Point2D p = (Point2D)create(context, c);;
      p.setLocation(
        context.convert(0, list.get(0), double.class),
        context.convert(1, list.get(1), double.class)
      );
      return c.cast(p);
    }
    return super.postparse(context, value, c, t);
  }
  
  <span class="comment">// 型cに対するインスタンスを生成します（parseでのみ有効です）。</span>
  protected <span class="em">&lt;T&gt; T create(Context context, Class&lt;? extends T&gt; c)</span> throws Exception {
    if (Point2D.class.isAssignableFrom(c)) {
      return c.cast(new Point2D.Double());
    }
    return super.create(context, c);
  }
      
  <span class="comment">// Class cにおいて、Member mを無視します（parse/formatの両方で有効です）。</span>
  protected <span class="em">boolean ignore(Context context, Class c, Member m)</span> {
    <span class="comment">// デフォルトでは、static/transparentのメンバおよびObjectクラスで宣言された
    // メンバの場合、trueを返します。</span>
    return super.ignore(context, c, m);
  }    
};
</pre>

<p>また、継承して作成した自作クラスをJSON.prototypeにセットすることで、JSON.encodeやJSON.decodeの動作を置き換えることも可能です。</p>
<pre class="source">
JSON.prototype = MyJSON.class;
</pre>

<h3 id="generics">■ 総称型を指定してのdecode/parse</h3>
<p>Java 5.0で追加された総称型は動的な情報としては利用できないため、decode/parseメソッドのClass型引数として直接指定することができません。その代わり、FieldやMethodを利用することで間接的に指定することができます。</p>
<pre class="source">
public class JSONConfigLoader {
  private Map&lt;String, Hoge&gt; config;
  
  public Map load(Reader reader) throws JSONException, IOException {
    JSON json = new JSON();
    
    <span class="comment">// これはコンパイルエラー</span>
    config = json.<span class="em">parse(</span>reader, Map&lt;String, Hoge&gt;.class<span class="em">)</span>;
    
    <span class="comment">// これならOK</span>
    config = (Map&lt;String, Hoge&gt;)json.<span class="em">parse(</span>reader,
        getClass().getField("config").getGenericType()<span class="em">)</span>;
        
    return config;
  }
}
</pre>

<h3 id="liberalparsing">■ 柔軟な読み込み <span class="subtitle">- 妥当でないJSONのデコード</span></h3>
<p>JSONICはポステルの法則（送信するものに関しては厳密に、受信するものに関しては寛容に）に従い、妥当でないJSONであっても読み込みが可能なように作成されています。<a 
href="http://www.rfc-editor.org/rfc/rfc4627.txt">RFC 4627</a>に規定された内容との相違点は以下の通りです。</p>
<ul>
  <li>Cスタイルの複数行コメント（/**/）、C++スタイルの行コメント（//）およびシェルスクリプトスタイルの行コメント（#）をコメントとして認識します。</li>
  <li>ルート要素がobjectの場合、一番外側の'{'と'}'を省略することができます（入力文字列が空白文字列やコメントのみの場合も空のobjectとみなされます）。</li>
  <li>シングルクォートで囲まれた文字列やJavaリテラルを文字列として認識します（ただし、シングルクォートで囲まれた場合はjavascriptと異なりエスケープを処理しません）。</li>
  <li>objectやarrayにおいて各要素が改行で区切られているとき','を省略することができます。</li>
  <li>objectにおいてキーに対する値がobjectの場合、':'を省略することができます。</li>
  <li>string中で改行やタブなどの制御文字を有効な文字として認識します。</li>
  <li>objectやarrayにおいて値が省略された場合、nullとして認識します。</li>
</ul>
<p>例えば、次のテキストは<a href="http://www.rfc-editor.org/rfc/rfc4627.txt">RFC 4627</a>では無効ですが、JSONICでは読み込むことが可能です。</p>
<pre class="source">
# database settings
database {
  description: 'ms sql server
	connecter settings'
  user: sa
  password: xxxx // you need to replace your password.
}

/* 
  equals to {"database": {
     "description": "ms sql server\n\tconnecter settings",
     "user": "sa", "password": "xxxx"}}
*/
</pre>

<h3 id="innerclass">■ 内部クラスを利用したエンコード/デコード</h3>
<p>JSONの設定ファイルを解析したいような場合は、内部クラスやパッケージ・デフォルトのクラスを利用したいことがあります。<br />
JSONICでは、encode/decode/parse/formatの引数に指定されたクラスと同一パッケージの内部クラスや無名クラスを自動的にアクセス可能に変更します。<br />
ただし、この場合に生成された内部クラスのインスタンスには包含するクラスのインスタンスがセットされていない状態になります。内部クラスから包含するクラスのインスタンスにアクセスしたい場合や引数に指定したクラス以外のコンテキストで実行したい場合は、setContextを利用して明示的に指定してください。</p>
<pre class="source">
public class EnclosingClass {
  public void decode() {
    JSON json = <span class="em">new JSON()</span>; 
    InnerClass ic = json.parse("{\"a\": 100}", InnerClass.class); <span class="comment">// このクラスのコンテキストで動作</span>
    
    System.out.println("ic.a = " + ic.a); <span class="comment">// ic.a = 100</span>
    
    ic.accessEnclosingClass(); <span class="comment">// 実行時にNullPointerExceptionが発生</span>
    
    json.<span class="em">setContext(</span>this<span class="em">)</span>;  <span class="comment">// コンテキストを設定</span>
    ic = json.parse("{\"a\": 100}", InnerClass.class);
    
    ic.accessEnclosingClass(); <span class="comment">// 正常に動作</span>
  }
  
  class InnerClass {
    public int a = 0;
    
    public void accessEnclosingClass() {
      decode(); 
    }
  }
}
</pre>

<h3 id="maxdepth">■ setMaxDepth <span class="subtitle">- 最大深度の設定</span></h3>
<p>JSONICは、encode/format時に自分自身を戻すようなフィールドやプロパティ、配列を無視することで再帰による無限ループが発生することを防ぎます。
しかし、そのインスタンスにとって孫に当たるクラスが自分のインスタンスを返す場合にも再帰が発生してしまいます。JSONICでは、このような場合へ対処するため
単純に入れ子の深さに制限を設けています。</p>
<p>なお、最大深度の設定はdecode/parse時にも有効ですので深すぎるデータの取得を避けることも可能となります。</p>
<p>この最大深度は、デフォルトでは32に設定されていますが変更することも可能です。</p>
<pre class="source">
<span class="comment">// 5階層以下の情報は取得しない</span>
json<span class="em">.setMaxDepth(</span>5<span class="em">)</span>;
</pre>

<h3 id="suppressnull">■ setSuppressNull <span class="subtitle">- null値の抑制</span></h3>
<p>JSONICでは、format時に値がnullになっているJSON objectのメンバの出力を抑制したり、parse時にnull値の代入を抑制することができます。初期値はfalseです。</p>
<p>余計なメンバが大量に出力されてしまう、プロパティの初期値を優先したいなどの場合に有効です。</p>
<pre class="source">
<span class="comment">// null値の出力や代入を抑制します。</span>
json<span class="em">.setSuppressNull(</span>true<span class="em">)</span>;
</pre>

<h3 id="xmltojson">■ XMLからJSONへの変換</h3>
<p>JSONICでは、org.w3c.dom.Document/Elementから<a href="http://jsonml.org/">JsonML</a>への変換をサポートしています。
方法は、通常と同じようにencode/formatの引数にorg.w3c.dom.Document/Elementのインスタンスを設定するだけです。</p>
<pre class="source">
Document doc = builder.parse(new File("sample.xml"));
String xmljson = JSON.<span class="em">encode(</span>doc<span class="em">)</span>;
</pre>
<p>例えば、下記のXMLの場合</p>
<pre class="source">
<span class="elem">&lt;feed xmlns="</span>http://www.w3.org/2005/Atom<span class="elem">"&gt;</span>
  <span class="elem">&lt;title&gt;</span>Feed Title<span class="elem">&lt;/title&gt;</span>
  <span class="elem">&lt;entry&gt;</span>
    <span class="elem">&lt;title&gt;</span>Entry Title<span class="elem">&lt;/title&gt;</span>
  <span class="elem">&lt;/entry&gt;</span>
<span class="elem">&lt;/feed&gt;</span>
</pre>
<p>次のようなJSONが生成されます（実際にはタグ間の空白文字もTextNodeとして出力されます。不要な場合は、DOM作成時に取り除く必要があります）。</p>
<pre class="source">
["feed", {"xmlns": "http://www.w3.org/2005/Atom"}, 
	["title", "Feed Title"],
	["entry",
		["title", "Entry Title"],
	]
]
</pre>

<h3 id="jsonhint">■ JSONHintアノテーション <span class="subtitle">- 変換時ヒントの付加</span></h3>
<p>場合によってデフォルトの変換方式では不十分な場合があります。JSONICでは、メソッドやフィールドにJSONHintアノテーションを付加することで、
動作を部分的に制御することが可能です。</p>
<p>設定できる属性は次の通りです。</p>
<table class="table" summary="JSONHintアノテーションの属性">
<tr><th>属性名</th><th>値型</th><th>説明</th></tr>
<tr><td>name</td><td>String</td><td>出力/代入するキー名を変更します</td></tr>
<tr><td>format</td><td>String</td><td>対象の型がNumberあるいはDate型の場合は、指定したフォーマットに従って変換します。<br />
フォーマットの書式はそれぞれjava.text.DecimalFormat、java.text.SimpleDateFormatを参照してください。</td></tr>
<tr><td>type</td><td>Class</td><td>parse時に指定した型のインスタンスを生成します（対象の型のサブクラスを指定する必要があります）。</td></tr>
<tr><td>ignore</td><td>boolean</td><td>出力/代入対象から除外します</td></tr>
<tr><td>serialized</td><td>boolean</td><td>値がJSONであるものとして扱います。デフォルトはfalseです。
Format時はtoString()の値をそのまま出力<sup>(※7)</sup> 、Parse時は入力されたJSONをJava Objectに変換し再度formatした文字列が設定されます。</td></tr>
</table>
<div class="caption">
(※7) 出力される文字列は検証されないため妥当でないJSONが出力されてしまう可能性があることに注意してください。
逆に言えば、この機能を使うことでコメントやfunction呼び出しを出力することも可能です。
</div>

<pre class="source">
public class WithHintBean {
  <span class="comment">// format/parse時のキー値を変更</span>
  <span class="em">@JSONHint(</span>name="名前"<span class="em">)</span>
  public int keyValue = 100;
  
  <span class="comment">// format/parse時のフォーマットを指定</span>
  <span class="em">@JSONHint(</span>format="yyyy/MM/dd"<span class="em">)</span>
  public Date dateValue = new Date();
    
  <span class="comment">// 数値の時は、DecimalForamtとして認識される</span>
  <span class="em">@JSONHint(</span>format="##0.00"<span class="em">)</span>
  public int numberValue = 100;
    
  <span class="comment">// 配列やリストでもOK</span>
  <span class="em">@JSONHint(</span>format="yyyy/MM/dd"<span class="em">)</span>
  public List&lt;Date&gt; dateArray;
  
  <span class="comment">// メソッドにも付与可能（getter/setterで別のヒントを与えることも可）</span>
  <span class="em">@JSONHint(</span>format="yyyy/MM/dd"<span class="em">)</span>
  public int getMethodValue() {
    return 100;
  }
  
  <span class="comment">// ArrayListの代わりにLinkedListのインスタンスを生成</span>
  <span class="em">@JSONHint(</span>type=LinkedList.class<span class="em">)</span>
  public List&lt;String&gt; stringList;
    
  <span class="comment">// format/parse時に無視</span>
  <span class="em">@JSONHint(</span>ignore=true<span class="em">)</span>
  public int ignoreValue = 100;
    
  <span class="comment">// 値はJSON</span>
  <span class="em">@JSONHint(</span>serialized=true<span class="em">)</span>
  public String json = "{\"num\": 100, \"func\": sum(100, 200) /*illegal JSON*/}";
}
</pre>

<h3 id="serializable">■ JSONHintによるSerializable指定 <span class="subtitle">- データの部分シリアル化</span></h3>
<p>JSONHintアノテーションのtype属性に<code>java.io.Serializable</code>を指定することで、そのデータに関してはObjectInputStream/ObjectOutputStreamによりシリアル化されたバイト列データとして取り扱うことができます（バイト列はBase64でエンコードされJSON stringとして出力されます）。</p>
<pre class="source">
public class SerializableBean {
  <span class="em">@JSONHint(</span>type=Serializable.class<span class="em">)</span>
  public SerializableBean sb;
}
</pre>
<p>この機能を使うことで、JSON化が困難なオブジェクトもJSON-RPCなどでやり取りすることが可能となります。</p>

<h2 id="webservice">Web Service Servlet</h2>
<p>JSONICには、JSON-RPC1.0によるRPCモードとRestfull APIによるRESTモードの2 Way Web Service機能が用意されています。</p>

<h3>■ 設定方法</h3>
<p>JSON Web Service Servletの設定は簡単です。web.xmlにWebServiceServletを指定し、パスとClassのマッピングなどの設定を行うだけです。</p>
<pre class="source">
<span class="elem">&lt;servlet&gt;</span>
  <span class="elem">&lt;servlet-name&gt;</span>json-ws<span class="elem">&lt;/servlet-name&gt;</span>
  <span class="elem">&lt;servlet-class&gt;</span>net.arnx.jsonic.web.WebServiceServlet<span class="elem">&lt;/servlet-class&gt;</span>
  <span class="elem">&lt;init-param&gt;</span>
    <span class="elem">&lt;param-name&gt;</span>config<span class="elem">&lt;/param-name&gt;</span>
    <span class="elem">&lt;param-value&gt;</span>
    {
      "debug": true,
      "encoding": "UTF-8",
      "expire": true,
      "mappings": {
        "/{package}/{class}.{ext}": "sample.web.${package}.service.${class}Service",
        "/{class}.{ext}": "sample.${class}Service"
      }
    }
    <span class="elem">&lt;/param-value&gt;</span>
  <span class="elem">&lt;/init-param&gt;</span>
<span class="elem">&lt;/servlet&gt;</span>

<span class="elem">&lt;servlet-mapping&gt;</span>
  <span class="elem">&lt;servlet-name&gt;</span>json-ws<span class="elem">&lt;/servlet-name&gt;</span>
  <span class="elem">&lt;url-pattern&gt;</span>*.json<span class="elem">&lt;/url-pattern&gt;</span>
<span class="elem">&lt;/servlet-mapping&gt;</span>
</pre>
<p>configで設定できる値は次の通りです。</p>
<table class="table" summary="Config設定">
<tr><th>キー</th><th>値型</th><th>説明</th></tr>
<tr><td>container</td><td><code>net.arnx.jsonic.web.Container</code></td><td>クラスのインスタンスを取得するためのコンテナを設定します。デフォルトは、<code>net.arnx.jsonic.web.Container</code>です。</td></tr>
<tr><td>encoding</td><td><code>java.lang.String</code></td><td>Request/Responseの文字エンコーディングを設定します。デフォルトはUTF-8です。</td></tr>
<tr><td>expire</td><td><code>java.lang.Boolean</code></td><td>クライアントキャッシュを抑制するHTTPヘッダを出力します(<code>Cache-Control:&nbsp;no-cache, Pragma:&nbsp;no-cache, Expires:&nbsp;Tue,&nbsp;29&nbsp;Feb&nbsp;2000&nbsp;12:00:00&nbsp;GMT</code>)。デフォルトはtrueです。</td></tr>
<tr><td>debug</td><td><code>java.lang.Boolean</code></td><td>デバッグモードの有効/無効を切り替えます。デフォルトはfalseです。</td></tr>
<tr><td>mappings</td><td><code>java.util.Map&lt;String, String&gt;</code></td><td>URLパスとクラスのマッピングを行います。
パス中の<code>{<i>name</i>}</code>で囲まれた部分はクラス名の<code>${<i>name</i>}</code>に置換されます<sup>(※8)</sup>。
なお、RESTモードの場合、利用されなかった変数は引数としてメソッドに引き渡されます（RPCモードの場合は設定されません。詳しくはRESTモードの説明をご覧ください）。また、<code>{<i>name</i>:<i>regex</i>}</code>と記載することで、JSR-311同様パターンを設定することができます。</td></tr>
<tr><td>definitions</td><td><code>java.util.Map&lt;String, Pattern&gt;</code></td><td>mappings中の変数の定義を正規表現で設定します。設定されない場合は<code>[^/()]+</code>が設定されたものと扱われます。</td></tr>
<tr><td>init</td><td><code>java.lang.String</code></td><td>処理の実行前に呼び出されるメソッド名を設定します。デフォルトは<code>"init"</code>です。</td></tr>
<tr><td>destroy</td><td><code>java.lang.String</code></td><td>処理の実行後に呼び出されるメソッド名を設定します。デフォルトは<code>"destroy"</code>です。</td></tr>
<tr><td>processor</td><td><code>net.arnx.jsonic.JSON</code></td><td>処理に使用するJSONクラスを設定します。デフォルトは、<code>net.arnx.jsonic.web.WebServiceServlet.WebServiceJSON</code>です。</td></tr>
<tr><td>namingConversion</td><td>boolean</td><td>WebService呼び出し時のクラス名、メソッド名の変換を行うか否か設定します。デフォルトはtrueです。</td></tr>
</table>
<div class="caption">
(※8) 変数名のうち、classとpackageだけは特殊な扱いがされます。デフォルトでは、class変数中の文字列はUpperCamelに変換され、package変数中の「/」は「.」に変換されます。
また、URLパスにはコンテキストパスを含める必要はありません。
</div>

<h3>■ RPCモード</h3>
<p><a href="http://json-rpc.org/">JSON-RPC</a>は、JSONを使ったシンプルなRemote Procedure Callプロトコルです。JSON Web Service Servletでは、class変数の値が<code>"rpc"</code>であった場合、RPCモードとなります。</p>

<p>RPCモードでは、対象のパスに対し次のようなJSONをPOSTすることで、対象クラスのメソッドを呼び出すことができます（GET/PUT/DELETEは無効です）。paramsに指定された配列の値はメソッドの引数に指定された型に従い自動的に変換されます。なお、クラス名はUpperCamel、メソッド名はLowerCamelに自動的に変換されます。そして、実行後、戻り値がJSONに変換されクライアントに返されます。</p>
<pre class="source">
{
  "method": "class.method",
  "params": [ arg1, arg2, ... ],
  "id": request_id
}
</pre>
<p>class, methodにはそれぞれ変数の値、argNにはメソッドの引数を設定してください。requesst_idには送受信の同期確認用のキーとしてnull以外の任意の値を設定してください（HTTPでは、送信と受信は同期処理ですのでほとんど意味はありませんが、省略すると通知(Notification)モードとなりレスポンスのメッセージボディが返されませんので必ず値を指定してください）。</p>
<p>例えば、mappingsに "/[package]/[class].[ext]": "boo.${package}.${class}Service" という指定があった場合、 /foo/woo/rpc.jsonというパスに次のJSONがPOSTすると、boo.foo.woo.CalcServiceクラスのint plus(int a, int b)のようなメソッドが呼び出されます。</p>
<pre class="source">
{
  "method": "calc.plus",
  "params": [1,2],
  "id": 1
}
</pre>
<p>この時、レスポンスのメッセージボディとしては次のような結果が返されます。</p>
<pre class="source">
{
  "result": 3,
  "error": null,
  "id": 1
}
</pre>

<p>RPCモードでエラーが発生した場合にはレスポンスのメッセージボディでクライアントに通知されます。ステータスコードは、エラーの有無に関わらず200 OKが返されます。</p>
<p>errorの値には code, message, dataの三つのキーを持つJSON objectが設定されます。codeとmessageについては次表を参照してください。dataには投げられた例外のプロパティがセットされます（ただし、Throwableクラスのプロパティは除外されます）。</p>
<table class="table" summary="RPC エラー一覧">
<tr><th>エラー内容</th><th>HTTP Status Code</th><th>JSON error</th></tr>
<tr>
<td>JSONリクエストがJSON-RPCのリクエストとして不正</td>
<td>200&nbsp;OK</td>
<td><pre style="margin:0;">{
  "code": -32600,
  "name": "ReferenceError",
  "message": "Invalid Request."
}</pre></td>
</tr>
<tr>
<td>methodで指定したクラス/メソッドが見つからない<sup>(※9)</sup></td>
<td>200&nbsp;OK</td>
<td><pre style="margin:0;">{
  "code": -32601,
  "name": "ReferenceError",
  "message": "Method not found."
}</pre></td>
</tr>
<tr>
<td>paramsが不適切<sup>(※10)</sup></td>
<td>200&nbsp;OK</td>
<td><pre style="margin:0;">{
  "code": -32602,
  "name": "TypeError",
  "message": "Invalid params."
}</pre></td>
</tr>
<tr>
<td>JSONの解析に失敗した</td>
<td>200&nbsp;OK</td>
<td><pre style="margin:0;">{
  "code": -32700,
  "name": "SyntaxError",
  "message": "Parse error."
}</pre></td>
</tr>
<tr>
<td>その他のエラー</td>
<td>200&nbsp;OK</td>
<td><pre style="margin:0;">{
  "code": -32603,
  "name": Class#getSimpleName(),
  "message": "Internal error." or Throwable#getMessage()
  "data": Throwable
}</pre></td>
</tr>
</table>
<div class="caption">(※9) クラス/メソッドが見つからなかった時だけでなく、メソッドからIllegalStateExceptionやUnsupportedOperationExceptionが投げられた場合も同じエラーが返されます。</div>
<div class="caption">(※10) Convertに失敗した場合だけでなく、メソッドからIllegalArgumentExceptionが投げられた場合も同じエラーが返されます。</div>

<h3>■ RESTモード</h3>
<p>class変数の値が"rpc"以外の場合はRESTモードになります。RESTモードでは、GET/POST/PUT/DELETEの四つのHTTP Methodに従い対象となったクラスの次の名前のメソッドが呼び出されます<sup>(※11)</sup>。そして、実行後、戻り値がJSONに変換されクライアントに返されます<sup>(※12)</sup>。</p>
<table class="table" summary="REST Method マッピング">
<tr><th>HTTP Method</th><th>Java メソッド名</th><th>引数</th></tr>
<tr><td>GET</td><td>find</td><td>クエリ変数名を「.」で区切られた階層構造とみなし引数の型に従い変換し設定</td></tr>
<tr><td>POST</td><td>create</td><td rowspan="3">リクエストのメッセージボディを引数の型に従い変換し設定<sup>(※13)</sup></td></tr>
<tr><td>PUT</td><td>update</td></tr>
<tr><td>DELETE</td><td>delete</td></tr>
</table>
<p>なお、上記のメソッド名は変更することが可能です。その場合は対象のマッピングを配列化し、二番目の引数にHTTP Methodとメソッド名のマッピングを記載します。例えば、.csvに対してGETでアクセスされた場合にprintというメソッドを呼び出したい場合は次のようにします。</p>
<pre class="source">
<span class="elem">&lt;servlet&gt;</span>
  ...
  <span class="elem">&lt;init-param&gt;</span>
    <span class="elem">&lt;param-name&gt;</span>config<span class="elem">&lt;/param-name&gt;</span>
    <span class="elem">&lt;param-value&gt;</span>
    {
      "mappings": {
      　<span class="comment">// GET *.csvにアクセスされた場合はprintメソッドを呼び出します。</span>
        "/{package}/{class}.csv": ["sample.web.${package}.service.${class}Service", {"GET": "print"}]
        "/{package}/{class}.{ext}": "sample.web.${package}.service.${class}Service"
      }
    }
    <span class="elem">&lt;/param-value&gt;</span>
  <span class="elem">&lt;/init-param&gt;</span>
<span class="elem">&lt;/servlet&gt;</span>
</pre>

<p>引数には送信されたJSONが指定された型に従い変換されセットされます。引数への設定は、JSONの型によって次のような違いがあります。</p>
<table class="table" summary="引数設定一覧">
<tr><th>Request&nbsp;Type</th><th>説明</th></tr>
<tr><td>object</td><td>パス変数、クエリ変数、リクエストボディの値が順に上書きされたJSON objectが設定されます（同じキーが複数出現した場合は配列化されます）。</td></tr>
<tr><td>array</td><td>送信されたJSON arrayを引数リストとして扱います。
なお、第一引数がJSON objectである場合には、上記と同様にパス変数、クエリ変数、第一引数の順でデータが上書きされる形で設定されます。
その他の型であった場合や第二引数以降はそのまま設定されます。</td></tr>
</table>
<div class="caption">
(※11) ブラウザなどでは、PUT/DELETEが使えない場合があります。そのような場合の代替手段として、クエリ変数に「_method=HTTP Method名」を指定することもできます。<br />
(※12) JSONはobjectかarrayより始まる必要があるため、それ以外の要素に変換される型の戻り値（例えば、boolean/int/Dateなど）の場合にはSC_NO_CONTENTが返されます。<br />
(※13) Content-Typeが「<code>application/x-www-form-urlencoded</code>」の場合には、GETの場合と同様にフォームのパラメータ名を「.」で区切られた階層構造とみなして扱います。
</div>

<p>RESTモードでは、エラーの発生はHTTP Status Codeによりクライアントに通知されます。</p>
<table class="table" summary="RPC エラー一覧">
<tr><th>エラー内容</th><th>HTTP Status Code</th></tr>
<tr>
<td>クラス/メソッドが見つからない<sup>(※14)</sup></td>
<td>404&nbsp;Not&nbsp;found</td>
</tr>
<tr>
<td>送信されたJSONの解析/変換に失敗した<sup>(※15)</sup></td>
<td>400&nbsp;Bad&nbsp;request</td>
</tr>
<tr>
<td>その他のエラー</td>
<td>500&nbsp;Internal&nbsp;Server&nbsp;Error</td>
</tr>
</table>
<div class="caption">(※14) クラス/メソッドが見つからなかった時だけでなく、メソッドからIllegalStateExceptionやUnsupportedOperationExceptionが発生した場合も同じエラーが返されます。</div>
<div class="caption">(※15) Convertに失敗した場合だけでなく、メソッドからIllegalStateException、UnsupportedOperationException、Error<b>以外</b>の例外が発生した場合も同じエラーが返されます。
なお、この場合、発生した例外がJSON objectとしてメッセージボディに設定されます（ただし、Throwableクラスのプロパティは除外されます）。</div>

<h3>■ JSONP</h3>
<p>RESTモードでかつHTTP MethodがGETの場合、リクエストパラメータとしてcallback=Function名を指定することでJSONPによる返答を返すことができるようになります。</p>
<pre class="source">
&lt;script type="text/javascript" &gt;
  function call(value) {
    alert(value);
  }
&lt;/script&gt;

...

&lt;script type="text/javascript" src="http://host/hoge.json?callback=call"&gt;&lt;/script&gt;
</pre>

<h3>■ 初期化/終了処理</h3>
<p>呼び出し対象となるクラスにinitあるいはdestroyという名前のメソッドがある場合、それぞれ処理の前後によびだされます。<sup>(※16)</sup></p>
<pre class="source">
public class HogeService {
  <span class="comment">// 処理の前に呼び出されます。</span>
  public void init() {
  }
  
  ...
  
  <span class="comment">// 処理の後に呼び出されます。</span>
  public void destroy() {
  }
}
</pre>
<div class="caption">(※16) 呼び出されるメソッド名は設定で変更可能です。</div>

<h3>■ Produceアノテーション <span class="subtitle">- JSON以外のレスポンス</span></h3>
<p>呼び出し先のメソッドにProduceアノテーションを付与することでレスポンスを自分で記述できるようになりJSON以外のレスポンスも返すことができるようになります。Produceアノテーションの引数には、出力するContent-Typeを指定します。</p>
<pre class="source">
public class HogeService {
  <span class="comment">// format/parse時のキー値を変更</span>
  <span class="em">@Produce(</span>"text/csv"<span class="em">)</span>
  public void print() throws IOException {
    response.setCharcterEncoding("MS932");
    PrintWriter writer = response.getWriter();
    writer.write("a,b,c\r\n");
  }
}
</pre>

<h3>■ DI Container対応</h3>
<p>JSONRPCServletは、内部のコンテナを切り替えることで呼び出し対象のインスタンスを任意のDI Containerにて管理することが可能です。</p>

<pre class="source">
<span class="elem">&lt;servlet&gt;</span>
  <span class="elem">&lt;servlet-name&gt;</span>JSON-WebService<span class="elem">&lt;/servlet-name&gt;</span>
  <span class="elem">&lt;servlet-class&gt;</span>net.arnx.jsonic.web.WebServiceServlet<span class="elem">&lt;/servlet-class&gt;</span>
  <span class="elem">&lt;init-param&gt;</span>
    <span class="elem">&lt;param-name&gt;</span>config<span class="elem">&lt;/param-name&gt;</span>
    <span class="elem">&lt;param-value&gt;</span>
      <span class="comment">// "container": (net.arnx.jsonic.web.Containerを実装したクラス)</span>
      <span class="comment">// Seasar2対応Container</span>
      "container": "net.arnx.jsonic.web.extension.Seasar2Container" 
      <span class="comment">// Spring Framework対応Container</span>
      "container": "net.arnx.jsonic.web.extension.SpringContainer"
      <span class="comment">// Google Guice対応Container</span>
      "container": "net.arnx.jsonic.web.extension.GuiceContainer"
      ...
    <span class="elem">&lt;/param-value&gt;</span>
  <span class="elem">&lt;/init-param&gt;</span>
<span class="elem">&lt;/servlet&gt;</span>
</pre>

<p>JSONICでは、<a href="http://www.seasar.org/">Seasar2</a>、<a href="http://www.springframework.org/">Spring Framework</a>、<a href="http://code.google.com/p/google-guice/">Google Guice</a>に対応したContainerを標準添付しています（※1.2よりパッケージ名やクラス名が変更されています。ご注意ください）。このContainerを利用すると、DI Container上で管理されているコンポーネントをWebServiceとして利用することができるようになります。</p>
<p>デフォルトでは最低限の機能のみ持つnet.arnx.jsonic.web.Containerが使われます。このコンテナが持つ機能は次の通りです。</p>
<ul>
<li>オブジェクトはClass#newInstance()により毎回生成されます。</li>
<li>ログは、ServletContext#log()を使って書き出されます。</li>
<li>JSPの暗黙オブジェクトライクなパブリックフィールドベースの簡易DIを提供します（下記例を参照）。</li>
</ul>
<pre class="source">
public class HogeService {
  <span class="comment">// Servlet関係のオブジェクトを設定します。クラスだけでなくフィールド名も合わせる必要があります。</span>
  public ServletConfig config;
  public ServletContext application;
  public HttpServletRequest request;
  public HttpServletResponse response;
  public HttpSession session;
}
</pre>

<h3>■ Gateway Filter</h3>
<p>JSONICでは、おまけ機能としてJSONを使ってServletで良く使う各種の機能を実装したFilterを提供しています。JSONICの書式を使えるため手軽に設定が可能です。</p>
<p>最初にマッチしたパスの設定が使われますが、そこで設定が行われなわれていない場合、ルートの設定が初期値として利用されます。パスには正規表現が利用できます。</p>
<pre class="source">
<span class="elem">&lt;filter&gt;</span>
  <span class="elem">&lt;filter-name&gt;</span>Gateway Filter<span class="elem">&lt;/filter-name&gt;</span>
  <span class="elem">&lt;filter-class&gt;</span>net.arnx.jsonic.web.GatewayFilter<span class="elem">&lt;/filter-class&gt;</span>
  <span class="elem">&lt;init-param&gt;</span>
    <span class="elem">&lt;param-name&gt;</span>config<span class="elem">&lt;/param-name&gt;</span>
    <span class="elem">&lt;param-value&gt;</span>
      <span class="comment">// 共通設定</span>
      encoding: 'UTF-8'          <span class="comment">// 文字コード設定</span>
      locale: 'en'               <span class="comment">// Responseのロケールを設定</span>
      compression: true          <span class="comment">// GZip圧縮</span>
      
      <span class="comment">// 拡張子がjsonのパスを対象</span>
      '.+\.json': {
        expire: true           <span class="comment">// クライアントキャッシュを無効化</span>
      }
      
      <span class="comment">// 例：日本向け設定</span>
      '/ja/([^.]+)': {
        forward: '/$1.json'     <span class="comment">// JSON Web Serviceに転送</span>
        encoding: 'SHIFT_JIS'
        expire: true
        locale: 'ja-JP'
        access: ['jpuser']    <span class="comment">// アクセス可能なロール</span>
      }
    <span class="elem">&lt;/param-value&gt;</span>
  <span class="elem">&lt;/init-param&gt;</span>
<span class="elem">&lt;/filter&gt;</span>

<span class="elem">&lt;filter-mapping&gt;</span>
  <span class="elem">&lt;filter-name&gt;</span>Gateway Filter<span class="elem">&lt;/filter-name&gt;</span>
  <span class="elem">&lt;url-pattern&gt;</span>/*<span class="elem">&lt;/url-pattern&gt;</span>
<span class="elem">&lt;/filter-mapping&gt;</span>
</pre>
<p>configで設定できる値は次の通りです。なお、これらの設定はフィルタの設定に関わらず一度だけしか適用されません。</p>
<table class="table" summary="Config設定">
<tr><th>キー</th><th>値型</th><th>説明</th></tr>
<tr><td>encoding</td><td><code>java.lang.String</code></td><td>Request/Responseの文字エンコーディングを設定します。デフォルトはnullです。</td></tr>
<tr><td>compression</td><td><code>java.lang.Boolean</code></td><td>クライアントから<code>Accept-Encoding: gzip or x-gzip</code>が送られる場合、ResponseをGZip圧縮します。</td></tr>
<tr><td>expire</td><td><code>java.lang.Boolean</code></td><td>クライアントキャッシュを抑制するHTTPヘッダを出力します(<code>Cache-Control:&nbsp;no-cache, Pragma:&nbsp;no-cache, Expires:&nbsp;Tue,&nbsp;29&nbsp;Feb&nbsp;2000&nbsp;12:00:00&nbsp;GMT</code>)。デフォルトは<code>false</code>です。</td></tr>
<tr><td>forward</td><td><code>java.lang.String</code></td><td>指定されたパスに転送します（パスはコンテキストパス以下を指定します。正規表現の置換変数が利用できます）。</td></tr>
<tr><td>access</td><td><code>java.util.Set&lt;String&gt;</code></td><td>アクセス可能なアプリケーションロールを配列で指定します（認証そのものはコンテナの機能などを使う必要があります）。</td></tr>
<tr><td>locale</td><td><code>java.util.Locale</code></td><td>Responseのロケールを設定します。</td></tr>
</table>
<p>なお、encodingとexpireに関してはWebServiceServlet側にも同様の設定が用意されていますが、基本的にWebServiceServlet側の設定が優先されます。
ただし、WebServiceServlet側が未設定の場合は、GatewayFilter側の設定が利用されます。</p>

<h2 id="as3">JSONIC for AS3</h2>
<p>JSONICでは、クライアントにAdobe FlexやAdobe Airを使用する場合を想定し、AS3版のJSONクラスとRemoteObjectライクなJSON-RPCクライアントライブラリを同梱しています。</p>

<h3>■ ActionScript3版 JSONライブラリ</h3>
<p>Java版JSONクラスとほぼ同じです。ただし、decode/parseメソッドでの特定クラスへの変換はサポートしていません（動的型で十分だと思いますので……）。</p>
<pre class="source">
import net.arnx.jsonic.JSON;

<span class="comment">// インスタンスをJSONに変換します</span>
var text:String = <span class="em">JSON.encode(</span>new Hoge()<span class="em">)</span>;

<span class="comment">// JSONをObjectに変換します</span>
var hoge:Object = <span class="em">JSON.decode(</span>text<span class="em">)</span>;
</pre>

<h3>■ ActionScript3版 JSON-RPCクライアントライブラリ</h3>
<p>RemoteObjectライクなJSON-RPCクライアントクラスです。使い方はmx:RemoteObjectやmx:WebServiceなどを参考にしてください（lastResultのBindingも可能です）。</p>
<pre class="source">
<span class="elem">&lt;mx:WindowedApplication xmlns:mx="</span>http://www.adobe.com/2006/mxml<span class="elem">" </span>
  <span class="elem">xmlns:js="</span>http://arnx.net/jsonic<span class="elem">"&gt;</span>
    
  &lt;!-- sourceにコンポーネント名、Operationのnameにメソッド名を指定します。 --&gt;
  <span class="elem">&lt;js:WebService id="</span>remote<span class="elem">" </span>
    <span class="elem">endpoint="</span>http://localhost:8080/sample/rpc/rpc.json<span class="elem">" </span>
    <span class="elem">source="</span>calc<span class="elem">" </span>
    <span class="elem">makeObjectsBindable="</span>false<span class="elem">" </span>
    <span class="elem">showBusyCursor="</span>true<span class="elem">"</span>
    <span class="elem">result="</span>onResult(event)<span class="elem">"</span>
    <span class="elem">fault="</span>onFault(event)<span class="elem">"&gt;</span>
    
    <span class="elem">&lt;js:Operation name="</span>plus<span class="elem">" result="</span>onResult(event)<span class="elem">" fault="</span>onFault(event)<span class="elem">" /&gt;</span>
    ...
  <span class="elem">&lt;/js:WebService&gt;</span>
    
  <span class="elem">&lt;mx:Button label="</span>実行<span class="elem">" click="</span>remote.plus(100, 200)<span class="elem">" /&gt;</span>
  <span class="elem">&lt;mx:TextInput id="</span>output<span class="elem">" text="</span>{remote.plus.lastResult}<span class="elem">" /&gt;</span>
    
  <span class="elem">&lt;mx:Script&gt;</span>
    &lt;![CDATA[
      private function onResult(event:ResultEvent) {
        trace(event.result); // 100+200 =&gt; 300
      }
      
      private function onFault(event:FaultEvent) {
        trace(event.fault.message);
      }
    ]]&gt;
  <span class="elem">&lt;/mx:Script&gt;</span>
<span class="elem">&lt;/mx:WindowedApplication&gt;</span>
</pre>

<h2 id="license">ライセンス</h2>
<p>JSONICは、<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>下で配布します。</p>
<p><b>自分のライブラリへの組み込んでいただいたり、その際にパッケージ名の変更や処理の変更など行っていただいて構いません。</b>保障はありませんが、ライセンスの範囲内でご自由にお使いください。</p>

<h2 id="report">バグ・要望の報告先</h2>
<p>バグや要望などは<a href="http://sourceforge.jp/projects/jsonic">JSONICプロジェクトサイト</a>の<a href="http://sourceforge.jp/projects/jsonic/ticket/">チケット</a>に報告ください。</p>

<h2 id="releasenote">リリースノート</h2>

<h3>2009/10/24 version 1.2.0</h3>

<ul>
<li>JSON.encode(or format)およびJSON.decode(or parse)にて<code>JSONHint(type=Serializable.class)</code>を指定した場合には<code>ObjectInputStream/ObjectOutputStream</code>を使いシリアライズによる変換を行うようにしました。</li>
<li>JSON.encode(or format)およびJSON.decode(or parse)にて<code>java.sql.RowId</code>の相互変換に対応しました。</li>
<li>JSON.encode(or format)にて<code>java.sql.Array, java.sql.Struct</code>のJSON化に対応しました（逆方向には対応していません。相互変換が必要な場合は<code>JSONHint(type=Serializable.class)</code>を指定しシリアル化してください）。</li>
<li>[非互換] JSON WebServiceにて1.1までは送信されたContent-Typeに関わらずJSONとして処理されていましたが、1.2以降では送信時のContent-Typeが「<code>application/json</code>」の場合のみJSONとして処理されます。</li>
<li>[非互換] JSON WebServiceにて各種DI Container用Containerクラスのパッケージを<code>net.arnx.jsonic.web</code>から<code>net.arnx.jsonic.web.extension</code>に変更しました。ご注意ください。</li>
<li>[非互換] JSON WebServiceのSeasar2用コンテナの名称を<code>net.arnx.jsonic.web.S2Container</code>から<code>net.arnx.jsonic.web.extension.Seasar2Container</code>に変更しました。</li>
<li>[非互換] JSON WebService用JSON Processorの名称を<code>net.arnx.jsonic.web.WebServiceServlet.JSON</code>から<code>net.arnx.jsonic.web.WebServiceServlet.WebServiceJSON</code>に変更しました。</li>
<li>[非互換] JSON WebServiceにてWebServiceServletに存在したpreinvoke, invoke, postinvokeの各メソッドは機能をContainerクラスに移動しpreinvoke, findMethod, postinvokeとなりました。</li>
<li>[非互換] JSON WebServiceにてpreinvoke, postinvokeの各メソッドの引数に実行対象のメソッドを追加しました。</li>
<li>JSON WebServiceにて、HTTP Methodに対応して呼ばれるメソッドをルート単位で変更できるようにしました。</li>
<li>JSON WebServiceにJSON以外のレスポンスを返せるようHttpServletResponseを自分で操作できるProduceアノテーションを追加しました。</li>
<li>JSON WebServiceにてContainerにリクエストの最初と最期にそれぞれ呼ばれるstartメソッドとendメソッドを追加しました。</li>
<li>JSON WebServiceにてContainerに一連の実行処理を束ねるexecuteメソッドを追加しました。WebServiceServlet以外からJSON WebSerivceの処理ロジックを呼びたい場合に利用できます。</li>
<li>JSON WebServiceにてFilterなど<code>WebServiceServlet</code>が呼ばれる前に<code>request.getParameter(String name)</code>などが呼ばれると、処理に失敗する問題に対応しました。
なお、Winstoneに限り、<code>request.getParameter(String name)</code>など呼び出し後、<code>request.getInputStream()</code>の呼び出しに失敗する不具合があるため同状況では動作しません。</li>
<li>JSON WebServiceのRPCモードにてエラー返却時、nameパラメータにクラスの単純名を設定するように変更しました。</li>
<li>ドキュメントのRESTモードの説明にてJSON arrayが送られた場合のパラメータ設定順の記載が誤っていた点を修正しました。クエリ変数、パス変数と記載されていましたが、実際にはパス変数、クエリ変数の順に設定されます。</li>
<li>sampleに同梱のprototype.jsとjquery.jsをそれぞれ1.6.1と1.3.2に更新しました。</li>
</ul>

<hr style="margin-top: 30px;" />
<div class="copyright">Copyright (C) 2007-2009 Hidekatsu Izuno All right reserved.</div>
</div>
</body>
</html>